!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	Development	//
ADTypes	adaption/Adaption.h	/^enum class ADTypes : size_t {$/;"	c
ARTSS_ADAPTION_ADAPTION_H_	adaption/Adaption.h	8;"	d
ARTSS_ADAPTION_LAYERS_H_	adaption/Layers.h	8;"	d
ARTSS_ADAPTION_VORTEX_H_	adaption/Vortex.h	8;"	d
ARTSS_ADVECTION_SLADVECT_H_	advection/SLAdvect.h	8;"	d
ARTSS_ANALYSIS_ANALYSIS_H_	analysis/Analysis.h	8;"	d
ARTSS_ANALYSIS_SOLUTION_H_	analysis/Solution.h	9;"	d
ARTSS_BOUNDARYCONDITION_DOMAINBOUNDARY_H	boundaryCondition/DomainBoundary.h	8;"	d
ARTSS_BOUNDARYCONDITION_OBSTACLEBOUNDARY_H	boundaryCondition/ObstacleBoundary.h	8;"	d
ARTSS_BOUNDARY_BOUNDARYCONTROLLER_H_	boundary/BoundaryController.h	8;"	d
ARTSS_BOUNDARY_BOUNDARYDATA_H_	boundary/BoundaryData.h	8;"	d
ARTSS_BOUNDARY_BOUNDARY_H_	boundary/Boundary.h	8;"	d
ARTSS_BOUNDARY_MULTIGRID_H_	boundary/Multigrid.h	8;"	d
ARTSS_BOUNDARY_OBSTACLE_H	boundary/Obstacle.h	8;"	d
ARTSS_BOUNDRY_BOUNDARYDATACONTROLLER_H	boundary/BoundaryDataController.h	8;"	d
ARTSS_BUOYANCYMMS_H	source/BuoyancyMMS.h	8;"	d
ARTSS_CUBE_H	source/Cube.h	8;"	d
ARTSS_DIFFUSION_COLOREDGAUSSSEIDEL_H	diffusion/ColoredGaussSeidelDiffuse.h	9;"	d
ARTSS_DIFFUSION_EXPLICITDIFFUSE_H_	diffusion/ExplicitDiffuse.h	8;"	d
ARTSS_DIFFUSION_JACOBIDIFFUSE_H_	diffusion/JacobiDiffuse.h	9;"	d
ARTSS_DOMAIN_H	Domain.h	8;"	d
ARTSS_FIELDCONTROLLER_H	field/FieldController.h	8;"	d
ARTSS_FIELD_H_	field/Field.h	8;"	d
ARTSS_FUNCTIONS_H_	Functions.h	8;"	d
ARTSS_GAUSSFUNCTION_H	source/GaussFunction.h	8;"	d
ARTSS_INTERFACES_IADVECTION_H_	interfaces/IAdvection.h	8;"	d
ARTSS_INTERFACES_IDIFFUSION_H_	interfaces/IDiffusion.h	8;"	d
ARTSS_INTERFACES_IPRESSURE_H_	interfaces/IPressure.h	8;"	d
ARTSS_INTERFACES_ISOLVER_H_	interfaces/ISolver.h	8;"	d
ARTSS_INTERFACES_ISOURCEFUNCTION_H	interfaces/ISourceFunction.h	8;"	d
ARTSS_INTERFACES_ISOURCE_H_	interfaces/ISource.h	8;"	d
ARTSS_INTERFACES_ITURBULENCE_H_	interfaces/ITurbulence.h	8;"	d
ARTSS_INTERFACE_IADAPTIONFUNCTION_H	interfaces/IAdaptionFunction.h	8;"	d
ARTSS_PRESSURE_VCYCLEMG_H_	pressure/VCycleMG.h	8;"	d
ARTSS_SOLVER_ADVECTIONDIFFUSIONSOLVER_H_	solver/AdvectionDiffusionSolver.h	8;"	d
ARTSS_SOLVER_ADVECTIONSOLVER_H_	solver/AdvectionSolver.h	8;"	d
ARTSS_SOLVER_DIFFUSIONSOLVER_H_	solver/DiffusionSolver.h	8;"	d
ARTSS_SOLVER_DIFFUSIONTURBSOLVER_H_	solver/DiffusionTurbSolver.h	8;"	d
ARTSS_SOLVER_NSSOLVER_H_	solver/NSSolver.h	7;"	d
ARTSS_SOLVER_NSTEMPCONSOLVER_H_	solver/NSTempConSolver.h	10;"	d
ARTSS_SOLVER_NSTEMPSOLVER_H_	solver/NSTempSolver.h	8;"	d
ARTSS_SOLVER_NSTEMPTURBCONSOLVER_H_	solver/NSTempTurbConSolver.h	9;"	d
ARTSS_SOLVER_NSTEMPTURBSOLVER_H_	solver/NSTempTurbSolver.h	8;"	d
ARTSS_SOLVER_NSTURBSOLVER_H_	solver/NSTurbSolver.h	8;"	d
ARTSS_SOLVER_PRESSURESOLVER_H_	solver/PressureSolver.h	8;"	d
ARTSS_SOLVER_SOLVERCONTROLLER_H	solver/SolverController.h	8;"	d
ARTSS_SOLVER_SOLVERSELECTION_H	solver/SolverSelection.h	8;"	d
ARTSS_SOURCE_EXPLICITEULERSOURCE_H_	source/ExplicitEulerSource.h	8;"	d
ARTSS_TIMEINTEGRATION_H_	TimeIntegration.h	8;"	d
ARTSS_TURBULENCE_CONSTSMAGORINSKY_H_	turbulence/ConstSmagorinsky.h	8;"	d
ARTSS_TURBULENCE_DYNAMICSMAGORINSKY_H_	turbulence/DynamicSmagorinsky.h	8;"	d
ARTSS_UTILITY_GLOBALMACROSTYPES_H_	utility/GlobalMacrosTypes.h	11;"	d
ARTSS_UTILITY_PARAMETERS_H	utility/Parameters.h	9;"	d
ARTSS_UTILITY_UTILITY_H_	utility/Utility.h	8;"	d
ARTSS_VISUALISATION_CSVWRITER_H	visualisation/CSVWriter.h	8;"	d
ARTSS_VISUALISATION_VISUAL_H_	visualisation/Visual.h	8;"	d
ARTSS_VISUALISATION_VTKWRITER_H	visualisation/VTKWriter.h	8;"	d
ARTSS_ZERO_H	source/Zero.h	8;"	d
ATTRIBUTE_NAME	utility/tinyxml2.h	/^        ATTRIBUTE_NAME		            	= 0,$/;"	e	enum:tinyxml2::StrPair::__anon3
ATTRIBUTE_VALUE	utility/tinyxml2.h	/^        ATTRIBUTE_VALUE		            	= NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon3
ATTRIBUTE_VALUE_LEAVE_ENTITIES	utility/tinyxml2.h	/^        ATTRIBUTE_VALUE_LEAVE_ENTITIES  	= NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon3
Accept	utility/tinyxml2.cpp	/^bool XMLComment::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLComment
Accept	utility/tinyxml2.cpp	/^bool XMLDeclaration::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLDeclaration
Accept	utility/tinyxml2.cpp	/^bool XMLDocument::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLDocument
Accept	utility/tinyxml2.cpp	/^bool XMLElement::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLElement
Accept	utility/tinyxml2.cpp	/^bool XMLText::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLText
Accept	utility/tinyxml2.cpp	/^bool XMLUnknown::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLUnknown
Adaption	adaption/Adaption.cpp	/^Adaption::Adaption(FieldController *field_controller) {$/;"	f	class:Adaption
Adaption	adaption/Adaption.h	/^class Adaption {$/;"	c	class:ADTypes
AdvectionDiffusionSolver	interfaces/ISolver.h	/^    inline static const std::string AdvectionDiffusionSolver = "AdvectionDiffusionSolver";$/;"	m	struct:SolverTypes
AdvectionDiffusionSolver	solver/AdvectionDiffusionSolver.cpp	/^AdvectionDiffusionSolver::AdvectionDiffusionSolver(FieldController *field_controller) {$/;"	f	class:AdvectionDiffusionSolver
AdvectionDiffusionSolver	solver/AdvectionDiffusionSolver.h	/^class AdvectionDiffusionSolver : public ISolver {$/;"	c
AdvectionMethods	solver/SolverSelection.h	/^struct AdvectionMethods {$/;"	s
AdvectionSolver	interfaces/ISolver.h	/^    inline static const std::string AdvectionSolver = "AdvectionSolver";$/;"	m	struct:SolverTypes
AdvectionSolver	solver/AdvectionSolver.cpp	/^AdvectionSolver::AdvectionSolver(FieldController *field_controlller) {$/;"	f	class:AdvectionSolver
AdvectionSolver	solver/AdvectionSolver.h	/^class AdvectionSolver : public ISolver {$/;"	c
Alloc	utility/tinyxml2.h	/^    virtual void* Alloc() {$/;"	f	class:tinyxml2::MemPoolT
Analysis	analysis/Analysis.cpp	/^Analysis::Analysis(Solution *solution) {$/;"	f	class:Analysis
Analysis	analysis/Analysis.h	/^class Analysis {$/;"	c
Attribute	utility/tinyxml2.cpp	/^const char* XMLElement::Attribute( const char* name, const char* value ) const$/;"	f	class:tinyxml2::XMLElement
BUF_SIZE	utility/tinyxml2.h	/^        BUF_SIZE = 200$/;"	e	enum:tinyxml2::XMLPrinter::__anon9
BUF_SIZE	utility/tinyxml2.h	/^    enum { BUF_SIZE = 200 };$/;"	e	enum:tinyxml2::XMLAttribute::__anon6
BUF_SIZE	utility/tinyxml2.h	/^    enum { BUF_SIZE = 200 };$/;"	e	enum:tinyxml2::XMLElement::__anon8
Beltrami	Functions.cpp	/^    void Beltrami(Field *outx, Field *outy, Field *outz, Field *outp, real t) {$/;"	f	namespace:Functions
Beltrami	Functions.cpp	/^const std::string FunctionNames::Beltrami = "Beltrami";$/;"	m	class:FunctionNames	file:
Beltrami	Functions.h	/^    static const std::string Beltrami;$/;"	m	struct:FunctionNames
BeltramiBC_p	Functions.cpp	/^    void BeltramiBC_p(Field *outx) {$/;"	f	namespace:Functions
BeltramiBC_u	Functions.cpp	/^    void BeltramiBC_u(Field *outx, real t) {$/;"	f	namespace:Functions
BeltramiBC_v	Functions.cpp	/^    void BeltramiBC_v(Field *outx, real t) {$/;"	f	namespace:Functions
BeltramiBC_w	Functions.cpp	/^    void BeltramiBC_w(Field *outx, real t) {$/;"	f	namespace:Functions
Block	utility/tinyxml2.h	/^    struct Block {$/;"	s	class:tinyxml2::MemPoolT
BoolAttribute	utility/tinyxml2.h	/^    bool	 BoolAttribute( const char* name ) const	{$/;"	f	class:tinyxml2::XMLElement
BoolValue	utility/tinyxml2.h	/^    bool	 BoolValue() const				{$/;"	f	class:tinyxml2::XMLAttribute
Boundary	boundary/Boundary.cpp	/^Boundary::Boundary(Obstacle **obstacleList, size_t numberOfObstacles, size_t size_obstacles, size_t level) {$/;"	f	class:Boundary
Boundary	boundary/Boundary.cpp	/^Boundary::Boundary(size_t level) {$/;"	f	class:Boundary
Boundary	boundary/Boundary.h	/^class Boundary {$/;"	c
BoundaryConditionNames	boundary/BoundaryData.cpp	/^inline static const std::vector<std::string> BoundaryConditionNames = {"neumann", "dirichlet", "periodic"};$/;"	v	file:
BoundaryController	boundary/BoundaryController.cpp	/^BoundaryController::BoundaryController() {$/;"	f	class:BoundaryController
BoundaryController	boundary/BoundaryController.h	/^class BoundaryController {$/;"	c
BoundaryData	boundary/BoundaryData.cpp	/^BoundaryData::BoundaryData() {$/;"	f	class:BoundaryData
BoundaryData	boundary/BoundaryData.h	/^class BoundaryData {$/;"	c
BoundaryDataController	boundary/BoundaryDataController.cpp	/^BoundaryDataController::BoundaryDataController() {$/;"	f	class:BoundaryDataController
BoundaryDataController	boundary/BoundaryDataController.h	/^class BoundaryDataController {$/;"	c
Buoyancy	solver/SolverSelection.h	/^    inline static const std::string Buoyancy = "Buoyancy";$/;"	m	struct:SourceMethods
BuoyancyForce	Functions.cpp	/^    void BuoyancyForce(Field *out, Field *T, Field *Ta) {$/;"	f	namespace:Functions
BuoyancyMMS	Functions.cpp	/^    void BuoyancyMMS(Field *outx, Field *outy, Field *outz, Field *outp, Field *outT, real t) {$/;"	f	namespace:Functions
BuoyancyMMS	Functions.cpp	/^const std::string FunctionNames::BuoyancyMMS = "BuoyancyMMS";$/;"	m	class:FunctionNames	file:
BuoyancyMMS	Functions.h	/^    static const std::string BuoyancyMMS;$/;"	m	struct:FunctionNames
BuoyancyMMS	source/BuoyancyMMS.cpp	/^BuoyancyMMS::BuoyancyMMS() {$/;"	f	class:BuoyancyMMS
BuoyancyMMS	source/BuoyancyMMS.h	/^class BuoyancyMMS: public ISourceFunction {$/;"	c
BuoyancyST_MMS	Functions.cpp	/^    void BuoyancyST_MMS(Field *out, real t) {$/;"	f	namespace:Functions
BuoyancyST_MMS	Functions.cpp	/^const std::string FunctionNames::BuoyancyST_MMS = "BuoyancyST_MMS";$/;"	m	class:FunctionNames	file:
BuoyancyST_MMS	Functions.h	/^    static const std::string BuoyancyST_MMS;$/;"	m	struct:FunctionNames
BuoyancyST_MMS	solver/SolverSelection.h	/^    inline static const std::string BuoyancyST_MMS = "BuoyancyST_MMS";$/;"	m	struct:SourceMethods
CARRIAGE_RETURN	utility/tinyxml2.cpp	/^static const char CARRIAGE_RETURN		= (char)0x0d;			\/\/ CR gets filtered out$/;"	v	file:
CData	utility/tinyxml2.h	/^    bool CData() const						{$/;"	f	class:tinyxml2::XMLText
CLOSED	utility/tinyxml2.h	/^        CLOSED,		\/\/ <foo\/>$/;"	e	enum:tinyxml2::XMLElement::__anon7
CLOSING	utility/tinyxml2.h	/^        CLOSING		\/\/ <\/foo>$/;"	e	enum:tinyxml2::XMLElement::__anon7
COLLAPSE_WHITESPACE	utility/tinyxml2.h	/^    COLLAPSE_WHITESPACE$/;"	e	enum:tinyxml2::Whitespace
COMMENT	utility/tinyxml2.h	/^        COMMENT				        = NEEDS_NEWLINE_NORMALIZATION$/;"	e	enum:tinyxml2::StrPair::__anon3
COUNT	utility/tinyxml2.h	/^    enum { COUNT = (4*1024)\/SIZE }; \/\/ Some compilers do not accept to use COUNT in private part if COUNT is private$/;"	e	enum:tinyxml2::MemPoolT::__anon5
CR	utility/tinyxml2.cpp	/^static const char CR = CARRIAGE_RETURN;$/;"	v	file:
CSVWriter	visualisation/CSVWriter.h	/^class CSVWriter {$/;"	c
CStr	utility/tinyxml2.h	/^    const char* CStr() const {$/;"	f	class:tinyxml2::XMLPrinter
CStrSize	utility/tinyxml2.h	/^    int CStrSize() const {$/;"	f	class:tinyxml2::XMLPrinter
CalcTurbViscosity	turbulence/ConstSmagorinsky.cpp	/^void ConstSmagorinsky::CalcTurbViscosity(Field *ev, Field *in_u, Field *in_v, Field *in_w, bool sync) {$/;"	f	class:ConstSmagorinsky
CalcTurbViscosity	turbulence/DynamicSmagorinsky.cpp	/^void DynamicSmagorinsky::CalcTurbViscosity(Field *ev, Field *in_u, Field *in_v, Field *in_w, bool sync) {$/;"	f	class:DynamicSmagorinsky
Capacity	utility/tinyxml2.h	/^    int Capacity() const				{$/;"	f	class:tinyxml2::DynArray
Chunk	utility/tinyxml2.h	/^    union Chunk {$/;"	u	class:tinyxml2::MemPoolT
Clear	utility/tinyxml2.cpp	/^void XMLDocument::Clear()$/;"	f	class:tinyxml2::XMLDocument
Clear	utility/tinyxml2.h	/^    void Clear() {$/;"	f	class:tinyxml2::DynArray
Clear	utility/tinyxml2.h	/^    void Clear() {$/;"	f	class:tinyxml2::MemPoolT
ClearBuffer	utility/tinyxml2.h	/^    void ClearBuffer() {$/;"	f	class:tinyxml2::XMLPrinter
CloseElement	utility/tinyxml2.cpp	/^void XMLPrinter::CloseElement( bool compactMode )$/;"	f	class:tinyxml2::XMLPrinter
ClosingType	utility/tinyxml2.h	/^    int ClosingType() const {$/;"	f	class:tinyxml2::XMLElement
CollapseWhitespace	utility/tinyxml2.cpp	/^void StrPair::CollapseWhitespace()$/;"	f	class:tinyxml2::StrPair
ColoredGaussSeidel	solver/SolverSelection.h	/^    inline static const std::string ColoredGaussSeidel = "ColoredGaussSeidel";$/;"	m	struct:DiffusionMethods
ColoredGaussSeidelDiffuse	diffusion/ColoredGaussSeidelDiffuse.cpp	/^ColoredGaussSeidelDiffuse::ColoredGaussSeidelDiffuse() {$/;"	f	class:ColoredGaussSeidelDiffuse
ColoredGaussSeidelDiffuse	diffusion/ColoredGaussSeidelDiffuse.h	/^class ColoredGaussSeidelDiffuse: public IDiffusion {$/;"	c
CompactMode	utility/tinyxml2.h	/^	virtual bool CompactMode( const XMLElement& )	{ return _compactMode; }$/;"	f	class:tinyxml2::XMLPrinter
ConstSmagorinsky	solver/SolverSelection.h	/^    inline static const std::string ConstSmagorinsky = "ConstSmagorinsky";$/;"	m	struct:TurbulenceMethods
ConstSmagorinsky	turbulence/ConstSmagorinsky.cpp	/^ConstSmagorinsky::ConstSmagorinsky() {$/;"	f	class:ConstSmagorinsky
ConstSmagorinsky	turbulence/ConstSmagorinsky.h	/^class ConstSmagorinsky : public ITurbulence {$/;"	c
ConvertUTF32ToUTF8	utility/tinyxml2.cpp	/^void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )$/;"	f	class:tinyxml2::XMLUtil
Cs	turbulence/DynamicSmagorinsky.h	/^    Field *Cs;                        \/\/ dynamic constant$/;"	m	class:DynamicSmagorinsky
Cube	solver/SolverSelection.h	/^    inline static const std::string Cube = "Cube";$/;"	m	struct:SourceMethods
Cube	source/Cube.cpp	/^Cube::Cube(real value, real x_start, real y_start, real z_start, real x_end, real y_end, real z_end) {$/;"	f	class:Cube
Cube	source/Cube.h	/^class Cube: public ISourceFunction {$/;"	c
CurrentAllocs	utility/tinyxml2.h	/^    int CurrentAllocs() const		{$/;"	f	class:tinyxml2::MemPoolT
DEBUG	utility/tinyxml2.h	54;"	d
DOUBLE_QUOTE	utility/tinyxml2.cpp	/^static const char DOUBLE_QUOTE			= '\\"';$/;"	v	file:
DeleteAttribute	utility/tinyxml2.cpp	/^void XMLElement::DeleteAttribute( XMLAttribute* attribute )$/;"	f	class:tinyxml2::XMLElement
DeleteAttribute	utility/tinyxml2.cpp	/^void XMLElement::DeleteAttribute( const char* name )$/;"	f	class:tinyxml2::XMLElement
DeleteChild	utility/tinyxml2.cpp	/^void XMLNode::DeleteChild( XMLNode* node )$/;"	f	class:tinyxml2::XMLNode
DeleteChildren	utility/tinyxml2.cpp	/^void XMLNode::DeleteChildren()$/;"	f	class:tinyxml2::XMLNode
DeleteNode	utility/tinyxml2.cpp	/^void XMLDocument::DeleteNode( XMLNode* node )	{$/;"	f	class:tinyxml2::XMLDocument
DeleteNode	utility/tinyxml2.cpp	/^void XMLNode::DeleteNode( XMLNode* node )$/;"	f	class:tinyxml2::XMLNode
DiffusionMethods	solver/SolverSelection.h	/^struct DiffusionMethods {$/;"	s
DiffusionSolver	interfaces/ISolver.h	/^    inline static const std::string DiffusionSolver = "DiffusionSolver";$/;"	m	struct:SolverTypes
DiffusionSolver	solver/DiffusionSolver.cpp	/^DiffusionSolver::DiffusionSolver(FieldController *field_controller) {$/;"	f	class:DiffusionSolver
DiffusionSolver	solver/DiffusionSolver.h	/^class DiffusionSolver: public ISolver {$/;"	c
DiffusionTurbSolver	interfaces/ISolver.h	/^    inline static const std::string DiffusionTurbSolver = "DiffusionTurbSolver";$/;"	m	struct:SolverTypes
DiffusionTurbSolver	solver/DiffusionTurbSolver.cpp	/^DiffusionTurbSolver::DiffusionTurbSolver(FieldController *field_controller) {$/;"	f	class:DiffusionTurbSolver
DiffusionTurbSolver	solver/DiffusionTurbSolver.h	/^class DiffusionTurbSolver: public ISolver {$/;"	c
Domain	Domain.cpp	/^Domain::Domain() {$/;"	f	class:Domain
Domain	Domain.h	/^class Domain {$/;"	c
DomainBoundary	boundaryCondition/DomainBoundary.cpp	/^namespace DomainBoundary {$/;"	n	file:
DomainBoundary	boundaryCondition/DomainBoundary.h	/^namespace DomainBoundary {$/;"	n
DoubleAttribute	utility/tinyxml2.h	/^    double 	 DoubleAttribute( const char* name ) const	{$/;"	f	class:tinyxml2::XMLElement
DoubleValue	utility/tinyxml2.h	/^    double 	 DoubleValue() const			{$/;"	f	class:tinyxml2::XMLAttribute
Drift	Functions.cpp	/^    void Drift(Field *outx, Field *outy, Field *outz, Field *outp) {$/;"	f	namespace:Functions
Drift	Functions.cpp	/^const std::string FunctionNames::Drift = "Drift";$/;"	m	class:FunctionNames	file:
Drift	Functions.h	/^    static const std::string Drift;$/;"	m	struct:FunctionNames
Drift_dynamic	adaption/Vortex.cpp	/^void Vortex::Drift_dynamic(const size_t *arr_idx, size_t arr_idx_size) {$/;"	f	class:Vortex
DynArray	utility/tinyxml2.h	/^    DynArray() {$/;"	f	class:tinyxml2::DynArray
DynArray	utility/tinyxml2.h	/^class DynArray$/;"	c	namespace:tinyxml2
DynamicSmagorinsky	solver/SolverSelection.h	/^    inline static const std::string DynamicSmagorinsky = "DynamicSmagorinsky";$/;"	m	struct:TurbulenceMethods
DynamicSmagorinsky	turbulence/DynamicSmagorinsky.cpp	/^DynamicSmagorinsky::DynamicSmagorinsky() {$/;"	f	class:DynamicSmagorinsky
DynamicSmagorinsky	turbulence/DynamicSmagorinsky.h	/^class DynamicSmagorinsky : public ITurbulence {$/;"	c
ENTITY_RANGE	utility/tinyxml2.h	/^        ENTITY_RANGE = 64,$/;"	e	enum:tinyxml2::XMLPrinter::__anon9
ENUM_TYPES	field/Field.h	18;"	d
Empty	utility/tinyxml2.h	/^    bool Empty() const					{$/;"	f	class:tinyxml2::DynArray
Empty	utility/tinyxml2.h	/^    bool Empty() const {$/;"	f	class:tinyxml2::StrPair
EnsureCapacity	utility/tinyxml2.h	/^    void EnsureCapacity( int cap ) {$/;"	f	class:tinyxml2::DynArray
Entity	utility/tinyxml2.cpp	/^struct Entity {$/;"	s	namespace:tinyxml2	file:
Error	utility/tinyxml2.h	/^    bool Error() const {$/;"	f	class:tinyxml2::XMLDocument
ErrorID	utility/tinyxml2.h	/^    XMLError  ErrorID() const {$/;"	f	class:tinyxml2::XMLDocument
ErrorName	utility/tinyxml2.cpp	/^const char* XMLDocument::ErrorName() const$/;"	f	class:tinyxml2::XMLDocument
ExpSinusProd	Functions.cpp	/^    void ExpSinusProd(Field *out, real t) {$/;"	f	namespace:Functions
ExpSinusProd	Functions.cpp	/^const std::string FunctionNames::ExpSinusProd = "ExpSinusProd";$/;"	m	class:FunctionNames	file:
ExpSinusProd	Functions.h	/^    static const std::string ExpSinusProd;$/;"	m	struct:FunctionNames
ExpSinusSum	Functions.cpp	/^    void ExpSinusSum(Field *outx, Field *outy, Field *outz, real t) {$/;"	f	namespace:Functions
ExpSinusSum	Functions.cpp	/^const std::string FunctionNames::ExpSinusSum = "ExpSinusSum";$/;"	m	class:FunctionNames	file:
ExpSinusSum	Functions.h	/^    static const std::string ExpSinusSum;$/;"	m	struct:FunctionNames
Explicit	solver/SolverSelection.h	/^    inline static const std::string Explicit = "Explicit";$/;"	m	struct:DiffusionMethods
ExplicitDiffuse	diffusion/ExplicitDiffuse.cpp	/^ExplicitDiffuse::ExplicitDiffuse() {$/;"	f	class:ExplicitDiffuse
ExplicitDiffuse	diffusion/ExplicitDiffuse.h	/^class ExplicitDiffuse : public IDiffusion {$/;"	c
ExplicitEuler	solver/SolverSelection.h	/^    inline static const std::string ExplicitEuler = "ExplicitEuler";$/;"	m	struct:SourceMethods
ExplicitEulerSource	source/ExplicitEulerSource.cpp	/^ExplicitEulerSource::ExplicitEulerSource() {$/;"	f	class:ExplicitEulerSource
ExplicitEulerSource	source/ExplicitEulerSource.h	/^class ExplicitEulerSource : public ISource {$/;"	c
ExplicitFiltering	turbulence/ConstSmagorinsky.cpp	/^void ConstSmagorinsky::ExplicitFiltering(Field *out, const Field *in, bool sync) {$/;"	f	class:ConstSmagorinsky
ExplicitFiltering	turbulence/DynamicSmagorinsky.cpp	/^void DynamicSmagorinsky::ExplicitFiltering(Field *out, const Field *in, bool sync) {$/;"	f	class:DynamicSmagorinsky
ExplicitStep	diffusion/ExplicitDiffuse.cpp	/^void ExplicitDiffuse::ExplicitStep(Field *out, const Field *in, const real D, bool sync) {$/;"	f	class:ExplicitDiffuse
ExplicitStep	diffusion/ExplicitDiffuse.cpp	/^void ExplicitDiffuse::ExplicitStep(Field *out, const Field *in, const real D, const Field *EV, bool sync) {$/;"	f	class:ExplicitDiffuse
FMT_USE_UDL_TEMPLATE	utility/Utility.h	15;"	d
FacSinSinSin	Functions.cpp	/^    void FacSinSinSin(Field *out) {$/;"	f	namespace:Functions
Field	field/Field.cpp	/^Field::Field(FieldType type, real val, size_t level, size_t size):$/;"	f	class:Field
Field	field/Field.h	/^class Field {$/;"	c
FieldController	field/FieldController.cpp	/^FieldController::FieldController() {$/;"	f	class:FieldController
FieldController	field/FieldController.h	/^class FieldController {$/;"	c
FieldTypeNames	boundary/BoundaryData.cpp	/^inline static const std::vector<std::string> FieldTypeNames = {"rho", "u", "v", "w", "p", "T"};$/;"	v	file:
FindAttribute	utility/tinyxml2.cpp	/^const XMLAttribute* XMLElement::FindAttribute( const char* name ) const$/;"	f	class:tinyxml2::XMLElement
FindAttribute	utility/tinyxml2.h	/^    XMLAttribute* FindAttribute( const char* name ) {$/;"	f	class:tinyxml2::XMLElement
FindOrCreateAttribute	utility/tinyxml2.cpp	/^XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )$/;"	f	class:tinyxml2::XMLElement
FirstAttribute	utility/tinyxml2.h	/^    const XMLAttribute* FirstAttribute() const {$/;"	f	class:tinyxml2::XMLElement
FirstChild	utility/tinyxml2.h	/^    XMLHandle FirstChild() 													{$/;"	f	class:tinyxml2::XMLHandle
FirstChild	utility/tinyxml2.h	/^    XMLNode*		FirstChild()			{$/;"	f	class:tinyxml2::XMLNode
FirstChild	utility/tinyxml2.h	/^    const XMLConstHandle FirstChild() const											{$/;"	f	class:tinyxml2::XMLConstHandle
FirstChild	utility/tinyxml2.h	/^    const XMLNode*  FirstChild() const		{$/;"	f	class:tinyxml2::XMLNode
FirstChildElement	utility/tinyxml2.cpp	/^const XMLElement* XMLNode::FirstChildElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
FirstChildElement	utility/tinyxml2.h	/^    XMLElement* FirstChildElement( const char* name = 0 )	{$/;"	f	class:tinyxml2::XMLNode
FirstChildElement	utility/tinyxml2.h	/^    XMLHandle FirstChildElement( const char* name = 0 )						{$/;"	f	class:tinyxml2::XMLHandle
FirstChildElement	utility/tinyxml2.h	/^    const XMLConstHandle FirstChildElement( const char* name = 0 ) const				{$/;"	f	class:tinyxml2::XMLConstHandle
Fits	utility/tinyxml2.cpp	/^bool LongFitsIntoSizeTMinusOne<false>::Fits( unsigned long \/*value*\/ )$/;"	f	class:tinyxml2::LongFitsIntoSizeTMinusOne
FloatAttribute	utility/tinyxml2.h	/^    float	 FloatAttribute( const char* name ) const	{$/;"	f	class:tinyxml2::XMLElement
FloatValue	utility/tinyxml2.h	/^    float	 FloatValue() const				{$/;"	f	class:tinyxml2::XMLAttribute
Free	utility/tinyxml2.h	/^    virtual void Free( void* mem ) {$/;"	f	class:tinyxml2::MemPoolT
FunctionNames	Functions.h	/^struct FunctionNames{$/;"	s
Functions	Functions.cpp	/^namespace Functions {$/;"	n	file:
Functions	Functions.h	/^namespace Functions {  \/\/ alphabetically ordered$/;"	n
GaussBubble	Functions.cpp	/^    void GaussBubble(Field *out, real t) {$/;"	f	namespace:Functions
GaussBubble	Functions.cpp	/^const std::string FunctionNames::GaussBubble = "GaussBubble";$/;"	m	class:FunctionNames	file:
GaussBubble	Functions.h	/^    static const std::string GaussBubble;$/;"	m	struct:FunctionNames
GaussFunction	source/GaussFunction.cpp	/^GaussFunction::GaussFunction(real HRR, real cp, real x0, real y0, real z0, real sigma_x, real sigma_y, real sigma_z, real tau) {$/;"	f	class:GaussFunction
GaussFunction	source/GaussFunction.h	/^class GaussFunction: public ISourceFunction {$/;"	c
GaussSC	solver/SolverSelection.h	/^    inline static const std::string GaussSC = "GaussSC";$/;"	m	struct:SourceMethods
GaussST	solver/SolverSelection.h	/^    inline static const std::string GaussST = "GaussST";$/;"	m	struct:SourceMethods
GetCharacterRef	utility/tinyxml2.cpp	/^const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )$/;"	f	class:tinyxml2::XMLUtil
GetDocument	utility/tinyxml2.h	/^    XMLDocument* GetDocument()				{$/;"	f	class:tinyxml2::XMLNode
GetDocument	utility/tinyxml2.h	/^    const XMLDocument* GetDocument() const	{$/;"	f	class:tinyxml2::XMLNode
GetErrorStr1	utility/tinyxml2.h	/^    const char* GetErrorStr1() const {$/;"	f	class:tinyxml2::XMLDocument
GetErrorStr2	utility/tinyxml2.h	/^    const char* GetErrorStr2() const {$/;"	f	class:tinyxml2::XMLDocument
GetP	analysis/Solution.h	/^    return_ptr GetP() const { return p_a.data; }$/;"	f	class:Solution
GetP_data	analysis/Solution.h	/^    real* GetP_data() const { return p_a.data; }$/;"	f	class:Solution
GetStr	utility/tinyxml2.cpp	/^const char* StrPair::GetStr()$/;"	f	class:tinyxml2::StrPair
GetT	analysis/Solution.h	/^    return_ptr GetT() const { return T_a.data; }$/;"	f	class:Solution
GetT_data	analysis/Solution.h	/^    real* GetT_data() const { return T_a.data; }$/;"	f	class:Solution
GetText	utility/tinyxml2.cpp	/^const char* XMLElement::GetText() const$/;"	f	class:tinyxml2::XMLElement
GetU	analysis/Solution.h	/^    return_ptr GetU() const { return u_a.data; }$/;"	f	class:Solution
GetU_data	analysis/Solution.h	/^    real* GetU_data() const { return u_a.data; }$/;"	f	class:Solution
GetV	analysis/Solution.h	/^    return_ptr GetV() const { return v_a.data; }$/;"	f	class:Solution
GetV_data	analysis/Solution.h	/^    real* GetV_data() const { return v_a.data; }$/;"	f	class:Solution
GetW	analysis/Solution.h	/^    return_ptr GetW() const { return w_a.data; }$/;"	f	class:Solution
GetW_data	analysis/Solution.h	/^    real* GetW_data() const { return w_a.data; }$/;"	f	class:Solution
HasBOM	utility/tinyxml2.h	/^    bool HasBOM() const {$/;"	f	class:tinyxml2::XMLDocument
Hat	Functions.cpp	/^    void Hat(Field *out) {$/;"	f	namespace:Functions
Hat	Functions.cpp	/^const std::string FunctionNames::Hat = "Hat";$/;"	m	class:FunctionNames	file:
Hat	Functions.h	/^    static const std::string Hat;$/;"	m	struct:FunctionNames
IAdaptionFunction	interfaces/IAdaptionFunction.h	/^class IAdaptionFunction {$/;"	c
IAdvection	interfaces/IAdvection.h	/^class IAdvection {$/;"	c
IDiffusion	interfaces/IDiffusion.h	/^class IDiffusion {$/;"	c
IPressure	interfaces/IPressure.h	/^class IPressure {$/;"	c
ISolver	interfaces/ISolver.h	/^class ISolver {$/;"	c
ISource	interfaces/ISource.h	/^class ISource {$/;"	c
ISourceFunction	interfaces/ISourceFunction.h	/^class ISourceFunction {$/;"	c
ITurbulence	interfaces/ITurbulence.h	/^class ITurbulence {$/;"	c
IX	utility/GlobalMacrosTypes.h	70;"	d
Identify	utility/tinyxml2.cpp	/^char* XMLDocument::Identify( char* p, XMLNode** node )$/;"	f	class:tinyxml2::XMLDocument
InsertAfterChild	utility/tinyxml2.cpp	/^XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )$/;"	f	class:tinyxml2::XMLNode
InsertChildPreamble	utility/tinyxml2.cpp	/^void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const$/;"	f	class:tinyxml2::XMLNode
InsertEndChild	utility/tinyxml2.cpp	/^XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )$/;"	f	class:tinyxml2::XMLNode
InsertFirstChild	utility/tinyxml2.cpp	/^XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )$/;"	f	class:tinyxml2::XMLNode
IntAttribute	utility/tinyxml2.h	/^    int		 IntAttribute( const char* name ) const		{$/;"	f	class:tinyxml2::XMLElement
IntValue	utility/tinyxml2.h	/^    int		 IntValue() const				{$/;"	f	class:tinyxml2::XMLAttribute
IsNameChar	utility/tinyxml2.h	/^    inline static bool IsNameChar( unsigned char ch ) {$/;"	f	class:tinyxml2::XMLUtil
IsNameStartChar	utility/tinyxml2.h	/^    inline static bool IsNameStartChar( unsigned char ch ) {$/;"	f	class:tinyxml2::XMLUtil
IsUTF8Continuation	utility/tinyxml2.h	/^    inline static bool IsUTF8Continuation( char p ) {$/;"	f	class:tinyxml2::XMLUtil
IsWhiteSpace	utility/tinyxml2.h	/^    static bool IsWhiteSpace( char p )					{$/;"	f	class:tinyxml2::XMLUtil
ItemSize	utility/tinyxml2.h	/^    virtual int ItemSize() const	{$/;"	f	class:tinyxml2::MemPoolT
JUROR_SURFACE_H	boundary/Surface.h	6;"	d
Jacobi	solver/SolverSelection.h	/^    inline static const std::string Jacobi = "Jacobi";$/;"	m	struct:DiffusionMethods
JacobiDiffuse	diffusion/JacobiDiffuse.cpp	/^JacobiDiffuse::JacobiDiffuse() {$/;"	f	class:JacobiDiffuse
JacobiDiffuse	diffusion/JacobiDiffuse.h	/^class JacobiDiffuse : public IDiffusion {$/;"	c
JacobiStep	diffusion/JacobiDiffuse.cpp	/^void JacobiDiffuse::JacobiStep(Field *out, const Field *in, const Field *b, const real alphaX, const real alphaY, const real alphaZ, const real rbeta, const real dsign, const real w, bool sync) {$/;"	f	class:JacobiDiffuse
JacobiStep	diffusion/JacobiDiffuse.cpp	/^void JacobiDiffuse::JacobiStep(Field *out, const Field *in, const Field *b, const real dsign, const real w, const real D, const Field *EV, const real dt, bool sync) {$/;"	f	class:JacobiDiffuse
JacobiStep	diffusion/JacobiDiffuse.cpp	/^void JacobiDiffuse::JacobiStep(size_t level, Field *out, const Field *in, const Field *b, const real alphaX, const real alphaY, const real alphaZ, const real beta, const real dsign, const real w, bool sync) {$/;"	f	class:JacobiDiffuse
L11	turbulence/DynamicSmagorinsky.h	/^    Field *L11, *L22, *L33, *L12, *L13, *L23;         \/\/ Leonard stress$/;"	m	class:DynamicSmagorinsky
L12	turbulence/DynamicSmagorinsky.h	/^    Field *L11, *L22, *L33, *L12, *L13, *L23;         \/\/ Leonard stress$/;"	m	class:DynamicSmagorinsky
L13	turbulence/DynamicSmagorinsky.h	/^    Field *L11, *L22, *L33, *L12, *L13, *L23;         \/\/ Leonard stress$/;"	m	class:DynamicSmagorinsky
L22	turbulence/DynamicSmagorinsky.h	/^    Field *L11, *L22, *L33, *L12, *L13, *L23;         \/\/ Leonard stress$/;"	m	class:DynamicSmagorinsky
L23	turbulence/DynamicSmagorinsky.h	/^    Field *L11, *L22, *L33, *L12, *L13, *L23;         \/\/ Leonard stress$/;"	m	class:DynamicSmagorinsky
L33	turbulence/DynamicSmagorinsky.h	/^    Field *L11, *L22, *L33, *L12, *L13, *L23;         \/\/ Leonard stress$/;"	m	class:DynamicSmagorinsky
LF	utility/tinyxml2.cpp	/^static const char LF = LINE_FEED;$/;"	v	file:
LINE_FEED	utility/tinyxml2.cpp	/^static const char LINE_FEED				= (char)0x0a;			\/\/ all line endings are normalized to LF$/;"	v	file:
LastChild	utility/tinyxml2.h	/^    XMLHandle LastChild()													{$/;"	f	class:tinyxml2::XMLHandle
LastChild	utility/tinyxml2.h	/^    XMLNode*		LastChild()								{$/;"	f	class:tinyxml2::XMLNode
LastChild	utility/tinyxml2.h	/^    const XMLConstHandle LastChild()	const										{$/;"	f	class:tinyxml2::XMLConstHandle
LastChild	utility/tinyxml2.h	/^    const XMLNode*	LastChild() const						{$/;"	f	class:tinyxml2::XMLNode
LastChildElement	utility/tinyxml2.cpp	/^const XMLElement* XMLNode::LastChildElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
LastChildElement	utility/tinyxml2.h	/^    XMLElement* LastChildElement( const char* name = 0 )	{$/;"	f	class:tinyxml2::XMLNode
LastChildElement	utility/tinyxml2.h	/^    XMLHandle LastChildElement( const char* name = 0 )						{$/;"	f	class:tinyxml2::XMLHandle
LastChildElement	utility/tinyxml2.h	/^    const XMLConstHandle LastChildElement( const char* name = 0 ) const				{$/;"	f	class:tinyxml2::XMLConstHandle
Layers	Functions.cpp	/^    void Layers(Field *out) {$/;"	f	namespace:Functions
Layers	adaption/Layers.cpp	/^Layers::Layers(FieldController *field_controller) {$/;"	f	class:Layers
Layers	adaption/Layers.h	/^class Layers : public IAdaptionFunction {$/;"	c
LinkEndChild	utility/tinyxml2.h	/^    XMLNode* LinkEndChild( XMLNode* addThis )	{$/;"	f	class:tinyxml2::XMLNode
LoadFile	utility/tinyxml2.cpp	/^XMLError XMLDocument::LoadFile( FILE* fp )$/;"	f	class:tinyxml2::XMLDocument
LoadFile	utility/tinyxml2.cpp	/^XMLError XMLDocument::LoadFile( const char* filename )$/;"	f	class:tinyxml2::XMLDocument
M11	turbulence/DynamicSmagorinsky.h	/^    Field *M11, *M22, *M33, *M12, *M13, *M23;       \/\/ High frequency resolved terms$/;"	m	class:DynamicSmagorinsky
M12	turbulence/DynamicSmagorinsky.h	/^    Field *M11, *M22, *M33, *M12, *M13, *M23;       \/\/ High frequency resolved terms$/;"	m	class:DynamicSmagorinsky
M13	turbulence/DynamicSmagorinsky.h	/^    Field *M11, *M22, *M33, *M12, *M13, *M23;       \/\/ High frequency resolved terms$/;"	m	class:DynamicSmagorinsky
M22	turbulence/DynamicSmagorinsky.h	/^    Field *M11, *M22, *M33, *M12, *M13, *M23;       \/\/ High frequency resolved terms$/;"	m	class:DynamicSmagorinsky
M23	turbulence/DynamicSmagorinsky.h	/^    Field *M11, *M22, *M33, *M12, *M13, *M23;       \/\/ High frequency resolved terms$/;"	m	class:DynamicSmagorinsky
M33	turbulence/DynamicSmagorinsky.h	/^    Field *M11, *M22, *M33, *M12, *M13, *M23;       \/\/ High frequency resolved terms$/;"	m	class:DynamicSmagorinsky
McDermott	Functions.cpp	/^    void McDermott(Field *outx, Field *outy, Field *outz, Field *outp, real t) {$/;"	f	namespace:Functions
McDermott	Functions.cpp	/^const std::string FunctionNames::McDermott = "McDermott";$/;"	m	class:FunctionNames	file:
McDermott	Functions.h	/^    static const std::string McDermott;$/;"	m	struct:FunctionNames
Mem	utility/tinyxml2.h	/^    T* Mem()							{$/;"	f	class:tinyxml2::DynArray
Mem	utility/tinyxml2.h	/^    const T* Mem() const				{$/;"	f	class:tinyxml2::DynArray
MemPool	utility/tinyxml2.h	/^    MemPool() {}$/;"	f	class:tinyxml2::MemPool
MemPool	utility/tinyxml2.h	/^class MemPool$/;"	c	namespace:tinyxml2
MemPoolT	utility/tinyxml2.h	/^    MemPoolT() : _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)	{}$/;"	f	class:tinyxml2::MemPoolT
MemPoolT	utility/tinyxml2.h	/^class MemPoolT : public MemPool$/;"	c	namespace:tinyxml2
Multigrid	boundary/Multigrid.cpp	/^Multigrid::Multigrid(BoundaryDataController *bdc_boundary) {$/;"	f	class:Multigrid
Multigrid	boundary/Multigrid.cpp	/^Multigrid::Multigrid(size_t numberOfSurfaces, Surface **surfaceList, size_t numberOfObstacles, Obstacle **obstacleList, BoundaryDataController *bdc_boundary, BoundaryDataController **bdc_obstacles) {$/;"	f	class:Multigrid
Multigrid	boundary/Multigrid.h	/^class Multigrid {$/;"	c
NEEDS_DELETE	utility/tinyxml2.h	/^        NEEDS_DELETE = 0x200$/;"	e	enum:tinyxml2::StrPair::__anon4
NEEDS_ENTITY_PROCESSING	utility/tinyxml2.h	/^        NEEDS_ENTITY_PROCESSING			= 0x01,$/;"	e	enum:tinyxml2::StrPair::__anon3
NEEDS_FLUSH	utility/tinyxml2.h	/^        NEEDS_FLUSH = 0x100,$/;"	e	enum:tinyxml2::StrPair::__anon4
NEEDS_NEWLINE_NORMALIZATION	utility/tinyxml2.h	/^        NEEDS_NEWLINE_NORMALIZATION		= 0x02,$/;"	e	enum:tinyxml2::StrPair::__anon3
NEEDS_WHITESPACE_COLLAPSING	utility/tinyxml2.h	/^        NEEDS_WHITESPACE_COLLAPSING     = 0x04,$/;"	e	enum:tinyxml2::StrPair::__anon3
NEGATIVE_SIGN	utility/GlobalMacrosTypes.h	81;"	d
NO	adaption/Adaption.h	/^    NO = 0, UNKNOWN = 1, YES = 2$/;"	m	class:ADTypes
NSSolver	interfaces/ISolver.h	/^    inline static const std::string NSSolver = "NSSolver";$/;"	m	struct:SolverTypes
NSSolver	solver/NSSolver.cpp	/^NSSolver::NSSolver(FieldController *field_controller) {$/;"	f	class:NSSolver
NSSolver	solver/NSSolver.h	/^class NSSolver : public ISolver {$/;"	c
NSTempConSolver	interfaces/ISolver.h	/^    inline static const std::string NSTempConSolver = "NSTempConSolver";$/;"	m	struct:SolverTypes
NSTempConSolver	solver/NSTempConSolver.cpp	/^NSTempConSolver::NSTempConSolver(FieldController *field_controller) {$/;"	f	class:NSTempConSolver
NSTempConSolver	solver/NSTempConSolver.h	/^class NSTempConSolver: public ISolver {$/;"	c
NSTempSolver	interfaces/ISolver.h	/^    inline static const std::string NSTempSolver = "NSTempSolver";$/;"	m	struct:SolverTypes
NSTempSolver	solver/NSTempSolver.cpp	/^NSTempSolver::NSTempSolver(FieldController *field_controller) {$/;"	f	class:NSTempSolver
NSTempSolver	solver/NSTempSolver.h	/^class NSTempSolver : public ISolver {$/;"	c
NSTempTurbConSolver	interfaces/ISolver.h	/^    inline static const std::string NSTempTurbConSolver = "NSTempTurbConSolver";$/;"	m	struct:SolverTypes
NSTempTurbConSolver	solver/NSTempTurbConSolver.cpp	/^NSTempTurbConSolver::NSTempTurbConSolver(FieldController *field_controller) {$/;"	f	class:NSTempTurbConSolver
NSTempTurbConSolver	solver/NSTempTurbConSolver.h	/^class NSTempTurbConSolver : public ISolver {$/;"	c
NSTempTurbSolver	interfaces/ISolver.h	/^    inline static const std::string NSTempTurbSolver = "NSTempTurbSolver";$/;"	m	struct:SolverTypes
NSTempTurbSolver	solver/NSTempTurbSolver.cpp	/^NSTempTurbSolver::NSTempTurbSolver(FieldController *field_controller) {$/;"	f	class:NSTempTurbSolver
NSTempTurbSolver	solver/NSTempTurbSolver.h	/^class NSTempTurbSolver : public ISolver {$/;"	c
NSTurbSolver	interfaces/ISolver.h	/^    inline static const std::string NSTurbSolver = "NSTurbSolver";$/;"	m	struct:SolverTypes
NSTurbSolver	solver/NSTurbSolver.cpp	/^NSTurbSolver::NSTurbSolver(FieldController *field_controller) {$/;"	f	class:NSTurbSolver
NSTurbSolver	solver/NSTurbSolver.h	/^class NSTurbSolver : public ISolver {$/;"	c
NUM_ENTITIES	utility/tinyxml2.cpp	/^static const int NUM_ENTITIES = 5;$/;"	m	namespace:tinyxml2	file:
Name	utility/tinyxml2.cpp	/^const char* XMLAttribute::Name() const $/;"	f	class:tinyxml2::XMLAttribute
Name	utility/tinyxml2.h	/^    const char* Name() const		{$/;"	f	class:tinyxml2::XMLElement
NewComment	utility/tinyxml2.cpp	/^XMLComment* XMLDocument::NewComment( const char* str )$/;"	f	class:tinyxml2::XMLDocument
NewDeclaration	utility/tinyxml2.cpp	/^XMLDeclaration* XMLDocument::NewDeclaration( const char* str )$/;"	f	class:tinyxml2::XMLDocument
NewElement	utility/tinyxml2.cpp	/^XMLElement* XMLDocument::NewElement( const char* name )$/;"	f	class:tinyxml2::XMLDocument
NewText	utility/tinyxml2.cpp	/^XMLText* XMLDocument::NewText( const char* str )$/;"	f	class:tinyxml2::XMLDocument
NewUnknown	utility/tinyxml2.cpp	/^XMLUnknown* XMLDocument::NewUnknown( const char* str )$/;"	f	class:tinyxml2::XMLDocument
Next	utility/tinyxml2.h	/^    const XMLAttribute* Next() const {$/;"	f	class:tinyxml2::XMLAttribute
NextSibling	utility/tinyxml2.h	/^    XMLHandle NextSibling()													{$/;"	f	class:tinyxml2::XMLHandle
NextSibling	utility/tinyxml2.h	/^    XMLNode*	NextSibling()								{$/;"	f	class:tinyxml2::XMLNode
NextSibling	utility/tinyxml2.h	/^    const XMLConstHandle NextSibling() const										{$/;"	f	class:tinyxml2::XMLConstHandle
NextSibling	utility/tinyxml2.h	/^    const XMLNode*	NextSibling() const						{$/;"	f	class:tinyxml2::XMLNode
NextSiblingElement	utility/tinyxml2.cpp	/^const XMLElement* XMLNode::NextSiblingElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
NextSiblingElement	utility/tinyxml2.h	/^    XMLElement*	NextSiblingElement( const char* name = 0 )	{$/;"	f	class:tinyxml2::XMLNode
NextSiblingElement	utility/tinyxml2.h	/^    XMLHandle NextSiblingElement( const char* name = 0 )					{$/;"	f	class:tinyxml2::XMLHandle
NextSiblingElement	utility/tinyxml2.h	/^    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const			{$/;"	f	class:tinyxml2::XMLConstHandle
NoChildren	utility/tinyxml2.h	/^    bool NoChildren() const					{$/;"	f	class:tinyxml2::XMLNode
OPEN	utility/tinyxml2.h	/^        OPEN,		\/\/ <foo>$/;"	e	enum:tinyxml2::XMLElement::__anon7
Obstacle	boundary/Obstacle.cpp	/^Obstacle::Obstacle(real x1, real x2, real y1, real y2, real z1, real z2) {$/;"	f	class:Obstacle
Obstacle	boundary/Obstacle.cpp	/^Obstacle::Obstacle(size_t coords_i1, size_t coords_j1, size_t coords_k1, size_t coords_i2, size_t coords_j2, size_t coords_k2, size_t level) {$/;"	f	class:Obstacle
Obstacle	boundary/Obstacle.h	/^class Obstacle {$/;"	c
ObstacleBoundary	boundaryCondition/ObstacleBoundary.cpp	/^namespace ObstacleBoundary {$/;"	n	file:
ObstacleBoundary	boundaryCondition/ObstacleBoundary.h	/^namespace ObstacleBoundary {$/;"	n
OpenElement	utility/tinyxml2.cpp	/^void XMLPrinter::OpenElement( const char* name, bool compactMode )$/;"	f	class:tinyxml2::XMLPrinter
P11	turbulence/DynamicSmagorinsky.h	/^    Field *P11, *P22, *P33, *P12, *P13, *P23;           \/\/ Product of strain modulus and strain tensor$/;"	m	class:DynamicSmagorinsky
P11_f	turbulence/DynamicSmagorinsky.h	/^    Field *P11_f, *P22_f, *P33_f, *P12_f, *P13_f, *P23_f;   \/\/ second filter for the above$/;"	m	class:DynamicSmagorinsky
P12	turbulence/DynamicSmagorinsky.h	/^    Field *P11, *P22, *P33, *P12, *P13, *P23;           \/\/ Product of strain modulus and strain tensor$/;"	m	class:DynamicSmagorinsky
P12_f	turbulence/DynamicSmagorinsky.h	/^    Field *P11_f, *P22_f, *P33_f, *P12_f, *P13_f, *P23_f;   \/\/ second filter for the above$/;"	m	class:DynamicSmagorinsky
P13	turbulence/DynamicSmagorinsky.h	/^    Field *P11, *P22, *P33, *P12, *P13, *P23;           \/\/ Product of strain modulus and strain tensor$/;"	m	class:DynamicSmagorinsky
P13_f	turbulence/DynamicSmagorinsky.h	/^    Field *P11_f, *P22_f, *P33_f, *P12_f, *P13_f, *P23_f;   \/\/ second filter for the above$/;"	m	class:DynamicSmagorinsky
P22	turbulence/DynamicSmagorinsky.h	/^    Field *P11, *P22, *P33, *P12, *P13, *P23;           \/\/ Product of strain modulus and strain tensor$/;"	m	class:DynamicSmagorinsky
P22_f	turbulence/DynamicSmagorinsky.h	/^    Field *P11_f, *P22_f, *P33_f, *P12_f, *P13_f, *P23_f;   \/\/ second filter for the above$/;"	m	class:DynamicSmagorinsky
P23	turbulence/DynamicSmagorinsky.h	/^    Field *P11, *P22, *P33, *P12, *P13, *P23;           \/\/ Product of strain modulus and strain tensor$/;"	m	class:DynamicSmagorinsky
P23_f	turbulence/DynamicSmagorinsky.h	/^    Field *P11_f, *P22_f, *P33_f, *P12_f, *P13_f, *P23_f;   \/\/ second filter for the above$/;"	m	class:DynamicSmagorinsky
P33	turbulence/DynamicSmagorinsky.h	/^    Field *P11, *P22, *P33, *P12, *P13, *P23;           \/\/ Product of strain modulus and strain tensor$/;"	m	class:DynamicSmagorinsky
P33_f	turbulence/DynamicSmagorinsky.h	/^    Field *P11_f, *P22_f, *P33_f, *P12_f, *P13_f, *P23_f;   \/\/ second filter for the above$/;"	m	class:DynamicSmagorinsky
POSITIVE_SIGN	utility/GlobalMacrosTypes.h	82;"	d
PRESERVE_WHITESPACE	utility/tinyxml2.h	/^    PRESERVE_WHITESPACE,$/;"	e	enum:tinyxml2::Whitespace
Parameters	utility/Parameters.h	/^    Parameters() {this->doc = new tinyxml2::XMLDocument;}$/;"	f	class:Parameters
Parameters	utility/Parameters.h	/^class Parameters {$/;"	c
Parent	utility/tinyxml2.h	/^    XMLNode* Parent()						{$/;"	f	class:tinyxml2::XMLNode
Parent	utility/tinyxml2.h	/^    const XMLNode*	Parent() const			{$/;"	f	class:tinyxml2::XMLNode
Parse	utility/tinyxml2.cpp	/^XMLError XMLDocument::Parse( const char* p, size_t len )$/;"	f	class:tinyxml2::XMLDocument
Parse	utility/tinyxml2.cpp	/^void XMLDocument::Parse()$/;"	f	class:tinyxml2::XMLDocument
ParseAttributes	utility/tinyxml2.cpp	/^char* XMLElement::ParseAttributes( char* p )$/;"	f	class:tinyxml2::XMLElement
ParseDeep	utility/tinyxml2.cpp	/^char* XMLAttribute::ParseDeep( char* p, bool processEntities )$/;"	f	class:tinyxml2::XMLAttribute
ParseDeep	utility/tinyxml2.cpp	/^char* XMLComment::ParseDeep( char* p, StrPair* )$/;"	f	class:tinyxml2::XMLComment
ParseDeep	utility/tinyxml2.cpp	/^char* XMLDeclaration::ParseDeep( char* p, StrPair* )$/;"	f	class:tinyxml2::XMLDeclaration
ParseDeep	utility/tinyxml2.cpp	/^char* XMLElement::ParseDeep( char* p, StrPair* strPair )$/;"	f	class:tinyxml2::XMLElement
ParseDeep	utility/tinyxml2.cpp	/^char* XMLNode::ParseDeep( char* p, StrPair* parentEnd )$/;"	f	class:tinyxml2::XMLNode
ParseDeep	utility/tinyxml2.cpp	/^char* XMLText::ParseDeep( char* p, StrPair* )$/;"	f	class:tinyxml2::XMLText
ParseDeep	utility/tinyxml2.cpp	/^char* XMLUnknown::ParseDeep( char* p, StrPair* )$/;"	f	class:tinyxml2::XMLUnknown
ParseName	utility/tinyxml2.cpp	/^char* StrPair::ParseName( char* p )$/;"	f	class:tinyxml2::StrPair
ParseText	utility/tinyxml2.cpp	/^char* StrPair::ParseText( char* p, const char* endTag, int strFlags )$/;"	f	class:tinyxml2::StrPair
PatchNames	boundary/BoundaryData.cpp	/^inline static const std::vector<std::string> PatchNames = {"front", "back", "bottom", "top", "left", "right"};$/;"	v	file:
PeekTop	utility/tinyxml2.h	/^    const T& PeekTop() const            {$/;"	f	class:tinyxml2::DynArray
Pop	utility/tinyxml2.h	/^    T Pop() {$/;"	f	class:tinyxml2::DynArray
PopArr	utility/tinyxml2.h	/^    void PopArr( int count ) {$/;"	f	class:tinyxml2::DynArray
PressureMethods	solver/SolverSelection.h	/^struct PressureMethods {$/;"	s
PressureSolver	interfaces/ISolver.h	/^    inline static const std::string PressureSolver = "PressureSolver";$/;"	m	struct:SolverTypes
PressureSolver	solver/PressureSolver.cpp	/^PressureSolver::PressureSolver(FieldController *field_controller) {$/;"	f	class:PressureSolver
PressureSolver	solver/PressureSolver.h	/^class PressureSolver : public ISolver {$/;"	c
PreviousSibling	utility/tinyxml2.h	/^    XMLHandle PreviousSibling()												{$/;"	f	class:tinyxml2::XMLHandle
PreviousSibling	utility/tinyxml2.h	/^    XMLNode*	PreviousSibling()							{$/;"	f	class:tinyxml2::XMLNode
PreviousSibling	utility/tinyxml2.h	/^    const XMLConstHandle PreviousSibling() const									{$/;"	f	class:tinyxml2::XMLConstHandle
PreviousSibling	utility/tinyxml2.h	/^    const XMLNode*	PreviousSibling() const					{$/;"	f	class:tinyxml2::XMLNode
PreviousSiblingElement	utility/tinyxml2.cpp	/^const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
PreviousSiblingElement	utility/tinyxml2.h	/^    XMLElement*	PreviousSiblingElement( const char* name = 0 ) {$/;"	f	class:tinyxml2::XMLNode
PreviousSiblingElement	utility/tinyxml2.h	/^    XMLHandle PreviousSiblingElement( const char* name = 0 )				{$/;"	f	class:tinyxml2::XMLHandle
PreviousSiblingElement	utility/tinyxml2.h	/^    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const		{$/;"	f	class:tinyxml2::XMLConstHandle
Print	utility/tinyxml2.cpp	/^void XMLDocument::Print( XMLPrinter* streamer ) const$/;"	f	class:tinyxml2::XMLDocument
Print	utility/tinyxml2.cpp	/^void XMLPrinter::Print( const char* format, ... )$/;"	f	class:tinyxml2::XMLPrinter
PrintError	utility/tinyxml2.cpp	/^void XMLDocument::PrintError() const$/;"	f	class:tinyxml2::XMLDocument
PrintSpace	utility/tinyxml2.cpp	/^void XMLPrinter::PrintSpace( int depth )$/;"	f	class:tinyxml2::XMLPrinter
PrintString	utility/tinyxml2.cpp	/^void XMLPrinter::PrintString( const char* p, bool restricted )$/;"	f	class:tinyxml2::XMLPrinter
ProcessEntities	utility/tinyxml2.h	/^    bool ProcessEntities() const		{$/;"	f	class:tinyxml2::XMLDocument
Prolongate	pressure/VCycleMG.cpp	/^void VCycleMG::Prolongate(Field *out, Field *in, size_t level, bool sync) {$/;"	f	class:VCycleMG
Push	utility/tinyxml2.h	/^    void Push( T t ) {$/;"	f	class:tinyxml2::DynArray
PushArr	utility/tinyxml2.h	/^    T* PushArr( int count ) {$/;"	f	class:tinyxml2::DynArray
PushAttribute	utility/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, bool v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	utility/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, const char* value )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	utility/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, double v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	utility/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, int v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	utility/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, unsigned v )$/;"	f	class:tinyxml2::XMLPrinter
PushComment	utility/tinyxml2.cpp	/^void XMLPrinter::PushComment( const char* comment )$/;"	f	class:tinyxml2::XMLPrinter
PushDeclaration	utility/tinyxml2.cpp	/^void XMLPrinter::PushDeclaration( const char* value )$/;"	f	class:tinyxml2::XMLPrinter
PushHeader	utility/tinyxml2.cpp	/^void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )$/;"	f	class:tinyxml2::XMLPrinter
PushText	utility/tinyxml2.cpp	/^void XMLPrinter::PushText( bool value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	utility/tinyxml2.cpp	/^void XMLPrinter::PushText( const char* text, bool cdata )$/;"	f	class:tinyxml2::XMLPrinter
PushText	utility/tinyxml2.cpp	/^void XMLPrinter::PushText( double value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	utility/tinyxml2.cpp	/^void XMLPrinter::PushText( float value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	utility/tinyxml2.cpp	/^void XMLPrinter::PushText( int value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	utility/tinyxml2.cpp	/^void XMLPrinter::PushText( unsigned value )$/;"	f	class:tinyxml2::XMLPrinter
PushUnknown	utility/tinyxml2.cpp	/^void XMLPrinter::PushUnknown( const char* value )$/;"	f	class:tinyxml2::XMLPrinter
QueryAttribute	utility/tinyxml2.h	/^	int QueryAttribute( const char* name, bool* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	utility/tinyxml2.h	/^	int QueryAttribute( const char* name, double* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	utility/tinyxml2.h	/^	int QueryAttribute( const char* name, float* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	utility/tinyxml2.h	/^	int QueryAttribute( const char* name, int* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	utility/tinyxml2.h	/^	int QueryAttribute( const char* name, unsigned int* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryBoolAttribute	utility/tinyxml2.h	/^    XMLError QueryBoolAttribute( const char* name, bool* value ) const				{$/;"	f	class:tinyxml2::XMLElement
QueryBoolText	utility/tinyxml2.cpp	/^XMLError XMLElement::QueryBoolText( bool* bval ) const$/;"	f	class:tinyxml2::XMLElement
QueryBoolValue	utility/tinyxml2.cpp	/^XMLError XMLAttribute::QueryBoolValue( bool* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryDoubleAttribute	utility/tinyxml2.h	/^    XMLError QueryDoubleAttribute( const char* name, double* value ) const			{$/;"	f	class:tinyxml2::XMLElement
QueryDoubleText	utility/tinyxml2.cpp	/^XMLError XMLElement::QueryDoubleText( double* dval ) const$/;"	f	class:tinyxml2::XMLElement
QueryDoubleValue	utility/tinyxml2.cpp	/^XMLError XMLAttribute::QueryDoubleValue( double* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryFloatAttribute	utility/tinyxml2.h	/^    XMLError QueryFloatAttribute( const char* name, float* value ) const			{$/;"	f	class:tinyxml2::XMLElement
QueryFloatText	utility/tinyxml2.cpp	/^XMLError XMLElement::QueryFloatText( float* fval ) const$/;"	f	class:tinyxml2::XMLElement
QueryFloatValue	utility/tinyxml2.cpp	/^XMLError XMLAttribute::QueryFloatValue( float* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryIntAttribute	utility/tinyxml2.h	/^    XMLError QueryIntAttribute( const char* name, int* value ) const				{$/;"	f	class:tinyxml2::XMLElement
QueryIntText	utility/tinyxml2.cpp	/^XMLError XMLElement::QueryIntText( int* ival ) const$/;"	f	class:tinyxml2::XMLElement
QueryIntValue	utility/tinyxml2.cpp	/^XMLError XMLAttribute::QueryIntValue( int* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryUnsignedAttribute	utility/tinyxml2.h	/^    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const	{$/;"	f	class:tinyxml2::XMLElement
QueryUnsignedText	utility/tinyxml2.cpp	/^XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const$/;"	f	class:tinyxml2::XMLElement
QueryUnsignedValue	utility/tinyxml2.cpp	/^XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const$/;"	f	class:tinyxml2::XMLAttribute
Random	Functions.cpp	/^    void Random(Field *out, real range, bool is_absolute, int seed, real step_size) {$/;"	f	namespace:Functions
RandomC	Functions.cpp	/^const std::string FunctionNames::RandomC = "RandomC";$/;"	m	class:FunctionNames	file:
RandomC	Functions.h	/^    static const std::string RandomC;$/;"	m	struct:FunctionNames
ReadBOM	utility/tinyxml2.cpp	/^const char* XMLUtil::ReadBOM( const char* p, bool* bom )$/;"	f	class:tinyxml2::XMLUtil
Reset	utility/tinyxml2.cpp	/^void StrPair::Reset()$/;"	f	class:tinyxml2::StrPair
Residuum	pressure/VCycleMG.cpp	/^void VCycleMG::Residuum(Field *out, Field *in, Field *b, size_t level, bool sync) {$/;"	f	class:VCycleMG
Restrict	pressure/VCycleMG.cpp	/^void VCycleMG::Restrict(Field *out, Field *in, size_t level, bool sync) {$/;"	f	class:VCycleMG
RootElement	utility/tinyxml2.h	/^    XMLElement* RootElement()				{$/;"	f	class:tinyxml2::XMLDocument
RootElement	utility/tinyxml2.h	/^    const XMLElement* RootElement() const	{$/;"	f	class:tinyxml2::XMLDocument
S11	turbulence/DynamicSmagorinsky.h	/^    Field *S11, *S22, *S33, *S12, *S13, *S23;         \/\/ strain tensor$/;"	m	class:DynamicSmagorinsky
S11_f	turbulence/DynamicSmagorinsky.h	/^    Field *S11_f, *S22_f, *S33_f, *S12_f, *S13_f, *S23_f;   \/\/ second filtered strain tensor$/;"	m	class:DynamicSmagorinsky
S12	turbulence/DynamicSmagorinsky.h	/^    Field *S11, *S22, *S33, *S12, *S13, *S23;         \/\/ strain tensor$/;"	m	class:DynamicSmagorinsky
S12_f	turbulence/DynamicSmagorinsky.h	/^    Field *S11_f, *S22_f, *S33_f, *S12_f, *S13_f, *S23_f;   \/\/ second filtered strain tensor$/;"	m	class:DynamicSmagorinsky
S13	turbulence/DynamicSmagorinsky.h	/^    Field *S11, *S22, *S33, *S12, *S13, *S23;         \/\/ strain tensor$/;"	m	class:DynamicSmagorinsky
S13_f	turbulence/DynamicSmagorinsky.h	/^    Field *S11_f, *S22_f, *S33_f, *S12_f, *S13_f, *S23_f;   \/\/ second filtered strain tensor$/;"	m	class:DynamicSmagorinsky
S22	turbulence/DynamicSmagorinsky.h	/^    Field *S11, *S22, *S33, *S12, *S13, *S23;         \/\/ strain tensor$/;"	m	class:DynamicSmagorinsky
S22_f	turbulence/DynamicSmagorinsky.h	/^    Field *S11_f, *S22_f, *S33_f, *S12_f, *S13_f, *S23_f;   \/\/ second filtered strain tensor$/;"	m	class:DynamicSmagorinsky
S23	turbulence/DynamicSmagorinsky.h	/^    Field *S11, *S22, *S33, *S12, *S13, *S23;         \/\/ strain tensor$/;"	m	class:DynamicSmagorinsky
S23_f	turbulence/DynamicSmagorinsky.h	/^    Field *S11_f, *S22_f, *S33_f, *S12_f, *S13_f, *S23_f;   \/\/ second filtered strain tensor$/;"	m	class:DynamicSmagorinsky
S33	turbulence/DynamicSmagorinsky.h	/^    Field *S11, *S22, *S33, *S12, *S13, *S23;         \/\/ strain tensor$/;"	m	class:DynamicSmagorinsky
S33_f	turbulence/DynamicSmagorinsky.h	/^    Field *S11_f, *S22_f, *S33_f, *S12_f, *S13_f, *S23_f;   \/\/ second filtered strain tensor$/;"	m	class:DynamicSmagorinsky
SINGLE_QUOTE	utility/tinyxml2.cpp	/^static const char SINGLE_QUOTE			= '\\'';$/;"	v	file:
SLAdvect	advection/SLAdvect.cpp	/^SLAdvect::SLAdvect() {$/;"	f	class:SLAdvect
SLAdvect	advection/SLAdvect.h	/^class SLAdvect : public IAdvection {$/;"	c
S_bar	turbulence/DynamicSmagorinsky.h	/^    Field *S_bar, *S_bar_f;                 \/\/ modulus of strain tensor$/;"	m	class:DynamicSmagorinsky
S_bar_f	turbulence/DynamicSmagorinsky.h	/^    Field *S_bar, *S_bar_f;                 \/\/ modulus of strain tensor$/;"	m	class:DynamicSmagorinsky
SaveFile	utility/tinyxml2.cpp	/^XMLError XMLDocument::SaveFile( FILE* fp, bool compact )$/;"	f	class:tinyxml2::XMLDocument
SaveFile	utility/tinyxml2.cpp	/^XMLError XMLDocument::SaveFile( const char* filename, bool compact )$/;"	f	class:tinyxml2::XMLDocument
SealElementIfJustOpened	utility/tinyxml2.cpp	/^void XMLPrinter::SealElementIfJustOpened()$/;"	f	class:tinyxml2::XMLPrinter
SemiLagrangian	solver/SolverSelection.h	/^    inline static const std::string SemiLagrangian = "SemiLagrangian";$/;"	m	struct:AdvectionMethods
Set	utility/tinyxml2.h	/^    void Set( char* start, char* end, int flags ) {$/;"	f	class:tinyxml2::StrPair
SetAdvectionSolver	solver/SolverSelection.cpp	/^void SetAdvectionSolver(IAdvection **advectionSolver, const std::string& advectionType) {$/;"	f	namespace:SolverSelection
SetAttribute	utility/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( bool v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	utility/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( const char* v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	utility/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( double v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	utility/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( float v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	utility/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( int v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	utility/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( unsigned v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	utility/tinyxml2.h	/^    void SetAttribute( const char* name, bool value )			{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	utility/tinyxml2.h	/^    void SetAttribute( const char* name, const char* value )	{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	utility/tinyxml2.h	/^    void SetAttribute( const char* name, double value )		{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	utility/tinyxml2.h	/^    void SetAttribute( const char* name, float value )		{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	utility/tinyxml2.h	/^    void SetAttribute( const char* name, int value )			{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	utility/tinyxml2.h	/^    void SetAttribute( const char* name, unsigned value )		{$/;"	f	class:tinyxml2::XMLElement
SetBOM	utility/tinyxml2.h	/^    void SetBOM( bool useBOM ) {$/;"	f	class:tinyxml2::XMLDocument
SetCData	utility/tinyxml2.h	/^    void SetCData( bool isCData )			{$/;"	f	class:tinyxml2::XMLText
SetDiffusionSolver	solver/SolverSelection.cpp	/^void SetDiffusionSolver(IDiffusion **diffusionSolver, const std::string& diffusionType) {$/;"	f	namespace:SolverSelection
SetError	utility/tinyxml2.cpp	/^void XMLDocument::SetError( XMLError error, const char* str1, const char* str2 )$/;"	f	class:tinyxml2::XMLDocument
SetInternedStr	utility/tinyxml2.h	/^    void SetInternedStr( const char* str ) {$/;"	f	class:tinyxml2::StrPair
SetName	utility/tinyxml2.cpp	/^void XMLAttribute::SetName( const char* n )$/;"	f	class:tinyxml2::XMLAttribute
SetName	utility/tinyxml2.h	/^    void SetName( const char* str, bool staticMem=false )	{$/;"	f	class:tinyxml2::XMLElement
SetPressureSolver	solver/SolverSelection.cpp	/^void SetPressureSolver(IPressure **pressureSolver, const std::string& pressureType, Field *p, Field *rhs) {$/;"	f	namespace:SolverSelection
SetSourceSolver	solver/SolverSelection.cpp	/^void SetSourceSolver(ISource **sourceSolver, const std::string& sourceType) {$/;"	f	namespace:SolverSelection
SetStr	utility/tinyxml2.cpp	/^void StrPair::SetStr( const char* str, int flags )$/;"	f	class:tinyxml2::StrPair
SetText	utility/tinyxml2.cpp	/^void	XMLElement::SetText( const char* inText )$/;"	f	class:tinyxml2::XMLElement
SetText	utility/tinyxml2.cpp	/^void XMLElement::SetText( bool v ) $/;"	f	class:tinyxml2::XMLElement
SetText	utility/tinyxml2.cpp	/^void XMLElement::SetText( double v ) $/;"	f	class:tinyxml2::XMLElement
SetText	utility/tinyxml2.cpp	/^void XMLElement::SetText( float v ) $/;"	f	class:tinyxml2::XMLElement
SetText	utility/tinyxml2.cpp	/^void XMLElement::SetText( int v ) $/;"	f	class:tinyxml2::XMLElement
SetText	utility/tinyxml2.cpp	/^void XMLElement::SetText( unsigned v ) $/;"	f	class:tinyxml2::XMLElement
SetTracked	utility/tinyxml2.h	/^    void SetTracked() {$/;"	f	class:tinyxml2::MemPoolT
SetTurbulenceSolver	solver/SolverSelection.cpp	/^void SetTurbulenceSolver(ITurbulence **turbulenceSolver, const std::string& turbulenceType) {$/;"	f	namespace:SolverSelection
SetValue	utility/tinyxml2.cpp	/^void XMLNode::SetValue( const char* str, bool staticMem )$/;"	f	class:tinyxml2::XMLNode
ShallowClone	utility/tinyxml2.cpp	/^XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLComment
ShallowClone	utility/tinyxml2.cpp	/^XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLDeclaration
ShallowClone	utility/tinyxml2.cpp	/^XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLElement
ShallowClone	utility/tinyxml2.cpp	/^XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLText
ShallowClone	utility/tinyxml2.cpp	/^XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLUnknown
ShallowClone	utility/tinyxml2.h	/^    virtual XMLNode* ShallowClone( XMLDocument* \/*document*\/ ) const	{$/;"	f	class:tinyxml2::XMLDocument
ShallowEqual	utility/tinyxml2.cpp	/^bool XMLComment::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLComment
ShallowEqual	utility/tinyxml2.cpp	/^bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLDeclaration
ShallowEqual	utility/tinyxml2.cpp	/^bool XMLElement::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLElement
ShallowEqual	utility/tinyxml2.cpp	/^bool XMLText::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLText
ShallowEqual	utility/tinyxml2.cpp	/^bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLUnknown
ShallowEqual	utility/tinyxml2.h	/^    virtual bool ShallowEqual( const XMLNode* \/*compare*\/ ) const	{$/;"	f	class:tinyxml2::XMLDocument
SinSinSin	Functions.cpp	/^    void SinSinSin(Field *out) {$/;"	f	namespace:Functions
SinSinSin	Functions.cpp	/^const std::string FunctionNames::SinSinSin = "SinSinSin";$/;"	m	class:FunctionNames	file:
SinSinSin	Functions.h	/^    static const std::string SinSinSin;$/;"	m	struct:FunctionNames
Size	utility/tinyxml2.h	/^    int Size() const					{$/;"	f	class:tinyxml2::DynArray
SkipWhiteSpace	utility/tinyxml2.h	/^    static char* SkipWhiteSpace( char* p )				{$/;"	f	class:tinyxml2::XMLUtil
SkipWhiteSpace	utility/tinyxml2.h	/^    static const char* SkipWhiteSpace( const char* p )	{$/;"	f	class:tinyxml2::XMLUtil
Smooth	pressure/VCycleMG.cpp	/^void VCycleMG::Smooth(Field *out, Field *tmp, Field *b, size_t level, bool sync) {$/;"	f	class:VCycleMG
Solution	analysis/Solution.cpp	/^Solution::Solution(const Domain &domain, std::string initial_condition ) :$/;"	f	class:Solution
Solution	analysis/Solution.h	/^class Solution {$/;"	c
Solve	pressure/VCycleMG.cpp	/^void VCycleMG::Solve(Field *out, Field *tmp, Field *b, size_t level, bool sync) {$/;"	f	class:VCycleMG
SolverController	solver/SolverController.cpp	/^SolverController::SolverController() {$/;"	f	class:SolverController
SolverController	solver/SolverController.h	/^class SolverController {$/;"	c
SolverSelection	solver/SolverSelection.cpp	/^namespace SolverSelection {$/;"	n	file:
SolverSelection	solver/SolverSelection.h	/^namespace SolverSelection {$/;"	n
SolverTypes	interfaces/ISolver.h	/^struct SolverTypes {$/;"	s
SourceMethods	solver/SolverSelection.h	/^struct SourceMethods {$/;"	s
StrPair	utility/tinyxml2.h	/^    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}$/;"	f	class:tinyxml2::StrPair
StrPair	utility/tinyxml2.h	/^class StrPair$/;"	c	namespace:tinyxml2
StringEqual	utility/tinyxml2.h	/^    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {$/;"	f	class:tinyxml2::XMLUtil
Surface	boundary/Surface.cpp	/^Surface::Surface(size_t surfaceID, size_t startIndex, size_t strideX, size_t strideY, size_t strideZ, size_t level) {$/;"	f	class:Surface
Surface	boundary/Surface.cpp	/^Surface::Surface(tinyxml2::XMLElement* element) {$/;"	f	class:Surface
Surface	boundary/Surface.h	/^class Surface {$/;"	c
TEXT_ELEMENT	utility/tinyxml2.h	/^        TEXT_ELEMENT		            	= NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon3
TEXT_ELEMENT_LEAVE_ENTITIES	utility/tinyxml2.h	/^        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon3
TINYXML2_INCLUDED	utility/tinyxml2.h	25;"	d
TINYXML2_LIB	utility/tinyxml2.h	65;"	d
TINYXML2_LIB	utility/tinyxml2.h	67;"	d
TINYXML2_LIB	utility/tinyxml2.h	69;"	d
TINYXML2_LIB	utility/tinyxml2.h	72;"	d
TIXML2_MAJOR_VERSION	utility/tinyxml2.h	/^static const int TIXML2_MAJOR_VERSION = 3;$/;"	v
TIXML2_MINOR_VERSION	utility/tinyxml2.h	/^static const int TIXML2_MINOR_VERSION = 0;$/;"	v
TIXML2_PATCH_VERSION	utility/tinyxml2.h	/^static const int TIXML2_PATCH_VERSION = 0;$/;"	v
TIXMLASSERT	utility/tinyxml2.h	79;"	d
TIXMLASSERT	utility/tinyxml2.h	82;"	d
TIXMLASSERT	utility/tinyxml2.h	85;"	d
TIXMLASSERT	utility/tinyxml2.h	88;"	d
TIXML_SNPRINTF	utility/tinyxml2.cpp	/^	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )$/;"	f	file:
TIXML_SNPRINTF	utility/tinyxml2.cpp	63;"	d	file:
TIXML_SNPRINTF	utility/tinyxml2.cpp	92;"	d	file:
TIXML_SSCANF	utility/tinyxml2.cpp	100;"	d	file:
TIXML_SSCANF	utility/tinyxml2.cpp	60;"	d	file:
TIXML_SSCANF	utility/tinyxml2.cpp	65;"	d	file:
TIXML_UTF_LEAD_0	utility/tinyxml2.cpp	/^static const unsigned char TIXML_UTF_LEAD_0 = 0xefU;$/;"	v	file:
TIXML_UTF_LEAD_1	utility/tinyxml2.cpp	/^static const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;$/;"	v	file:
TIXML_UTF_LEAD_2	utility/tinyxml2.cpp	/^static const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;$/;"	v	file:
TIXML_VSCPRINTF	utility/tinyxml2.cpp	/^		static inline int TIXML_VSCPRINTF( const char* format, va_list va )$/;"	f	file:
TIXML_VSCPRINTF	utility/tinyxml2.cpp	/^	static inline int TIXML_VSCPRINTF( const char* format, va_list va )$/;"	f	file:
TIXML_VSCPRINTF	utility/tinyxml2.cpp	59;"	d	file:
TIXML_VSCPRINTF	utility/tinyxml2.cpp	68;"	d	file:
TIXML_VSNPRINTF	utility/tinyxml2.cpp	/^	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )$/;"	f	file:
TIXML_VSNPRINTF	utility/tinyxml2.cpp	64;"	d	file:
TIXML_VSNPRINTF	utility/tinyxml2.cpp	93;"	d	file:
T_a	analysis/Solution.h	/^    Field T_a;$/;"	m	class:Solution
TimeIntegration	TimeIntegration.cpp	/^TimeIntegration::TimeIntegration(SolverController *sc) {$/;"	f	class:TimeIntegration
TimeIntegration	TimeIntegration.h	/^class TimeIntegration {$/;"	c
ToBool	utility/tinyxml2.cpp	/^bool XMLUtil::ToBool( const char* str, bool* value )$/;"	f	class:tinyxml2::XMLUtil
ToComment	utility/tinyxml2.h	/^    virtual XMLComment*		ToComment()		{$/;"	f	class:tinyxml2::XMLNode
ToComment	utility/tinyxml2.h	/^    virtual XMLComment*	ToComment()					{$/;"	f	class:tinyxml2::XMLComment
ToComment	utility/tinyxml2.h	/^    virtual const XMLComment*		ToComment() const		{$/;"	f	class:tinyxml2::XMLNode
ToComment	utility/tinyxml2.h	/^    virtual const XMLComment* ToComment() const		{$/;"	f	class:tinyxml2::XMLComment
ToDeclaration	utility/tinyxml2.h	/^    XMLDeclaration* ToDeclaration() 			{$/;"	f	class:tinyxml2::XMLHandle
ToDeclaration	utility/tinyxml2.h	/^    const XMLDeclaration* ToDeclaration() const	{$/;"	f	class:tinyxml2::XMLConstHandle
ToDeclaration	utility/tinyxml2.h	/^    virtual XMLDeclaration*	ToDeclaration()					{$/;"	f	class:tinyxml2::XMLDeclaration
ToDeclaration	utility/tinyxml2.h	/^    virtual XMLDeclaration*	ToDeclaration()	{$/;"	f	class:tinyxml2::XMLNode
ToDeclaration	utility/tinyxml2.h	/^    virtual const XMLDeclaration*	ToDeclaration() const	{$/;"	f	class:tinyxml2::XMLNode
ToDeclaration	utility/tinyxml2.h	/^    virtual const XMLDeclaration* ToDeclaration() const		{$/;"	f	class:tinyxml2::XMLDeclaration
ToDocument	utility/tinyxml2.h	/^    virtual XMLDocument*	ToDocument()	{$/;"	f	class:tinyxml2::XMLNode
ToDocument	utility/tinyxml2.h	/^    virtual XMLDocument* ToDocument()				{$/;"	f	class:tinyxml2::XMLDocument
ToDocument	utility/tinyxml2.h	/^    virtual const XMLDocument*		ToDocument() const		{$/;"	f	class:tinyxml2::XMLNode
ToDocument	utility/tinyxml2.h	/^    virtual const XMLDocument* ToDocument() const	{$/;"	f	class:tinyxml2::XMLDocument
ToDouble	utility/tinyxml2.cpp	/^bool XMLUtil::ToDouble( const char* str, double* value )$/;"	f	class:tinyxml2::XMLUtil
ToElement	utility/tinyxml2.h	/^    XMLElement* ToElement() 					{$/;"	f	class:tinyxml2::XMLHandle
ToElement	utility/tinyxml2.h	/^    const XMLElement* ToElement() const			{$/;"	f	class:tinyxml2::XMLConstHandle
ToElement	utility/tinyxml2.h	/^    virtual XMLElement*		ToElement()		{$/;"	f	class:tinyxml2::XMLNode
ToElement	utility/tinyxml2.h	/^    virtual XMLElement* ToElement()				{$/;"	f	class:tinyxml2::XMLElement
ToElement	utility/tinyxml2.h	/^    virtual const XMLElement*		ToElement() const		{$/;"	f	class:tinyxml2::XMLNode
ToElement	utility/tinyxml2.h	/^    virtual const XMLElement* ToElement() const {$/;"	f	class:tinyxml2::XMLElement
ToFloat	utility/tinyxml2.cpp	/^bool XMLUtil::ToFloat( const char* str, float* value )$/;"	f	class:tinyxml2::XMLUtil
ToInt	utility/tinyxml2.cpp	/^bool XMLUtil::ToInt( const char* str, int* value )$/;"	f	class:tinyxml2::XMLUtil
ToNode	utility/tinyxml2.h	/^    XMLNode* ToNode()							{$/;"	f	class:tinyxml2::XMLHandle
ToNode	utility/tinyxml2.h	/^    const XMLNode* ToNode() const				{$/;"	f	class:tinyxml2::XMLConstHandle
ToStr	utility/tinyxml2.cpp	/^void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	utility/tinyxml2.cpp	/^void XMLUtil::ToStr( double v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	utility/tinyxml2.cpp	/^void XMLUtil::ToStr( float v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	utility/tinyxml2.cpp	/^void XMLUtil::ToStr( int v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	utility/tinyxml2.cpp	/^void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToText	utility/tinyxml2.h	/^    XMLText* ToText() 							{$/;"	f	class:tinyxml2::XMLHandle
ToText	utility/tinyxml2.h	/^    const XMLText* ToText() const				{$/;"	f	class:tinyxml2::XMLConstHandle
ToText	utility/tinyxml2.h	/^    virtual XMLText*		ToText()		{$/;"	f	class:tinyxml2::XMLNode
ToText	utility/tinyxml2.h	/^    virtual XMLText* ToText()			{$/;"	f	class:tinyxml2::XMLText
ToText	utility/tinyxml2.h	/^    virtual const XMLText*			ToText() const			{$/;"	f	class:tinyxml2::XMLNode
ToText	utility/tinyxml2.h	/^    virtual const XMLText* ToText() const	{$/;"	f	class:tinyxml2::XMLText
ToUnknown	utility/tinyxml2.h	/^    XMLUnknown* ToUnknown() 					{$/;"	f	class:tinyxml2::XMLHandle
ToUnknown	utility/tinyxml2.h	/^    const XMLUnknown* ToUnknown() const			{$/;"	f	class:tinyxml2::XMLConstHandle
ToUnknown	utility/tinyxml2.h	/^    virtual XMLUnknown*		ToUnknown()		{$/;"	f	class:tinyxml2::XMLNode
ToUnknown	utility/tinyxml2.h	/^    virtual XMLUnknown*	ToUnknown()					{$/;"	f	class:tinyxml2::XMLUnknown
ToUnknown	utility/tinyxml2.h	/^    virtual const XMLUnknown*		ToUnknown() const		{$/;"	f	class:tinyxml2::XMLNode
ToUnknown	utility/tinyxml2.h	/^    virtual const XMLUnknown* ToUnknown() const		{$/;"	f	class:tinyxml2::XMLUnknown
ToUnsigned	utility/tinyxml2.cpp	/^bool XMLUtil::ToUnsigned( const char* str, unsigned *value )$/;"	f	class:tinyxml2::XMLUtil
Trace	utility/tinyxml2.h	/^    void Trace( const char* name ) {$/;"	f	class:tinyxml2::MemPoolT
TransferTo	utility/tinyxml2.cpp	/^void StrPair::TransferTo( StrPair* other )$/;"	f	class:tinyxml2::StrPair
TurbulenceMethods	solver/SolverSelection.h	/^struct TurbulenceMethods {$/;"	s
UNKNOWN	adaption/Adaption.h	/^    NO = 0, UNKNOWN = 1, YES = 2$/;"	m	class:ADTypes
Uniform	Functions.cpp	/^    void Uniform(Field *out, real val) {$/;"	f	namespace:Functions
Uniform	Functions.cpp	/^const std::string FunctionNames::Uniform = "Uniform";$/;"	m	class:FunctionNames	file:
Uniform	Functions.h	/^    static const std::string Uniform;$/;"	m	struct:FunctionNames
Uniform	solver/SolverSelection.h	/^    inline static const std::string Uniform = "Uniform";$/;"	m	struct:SourceMethods
Unlink	utility/tinyxml2.cpp	/^void XMLNode::Unlink( XMLNode* child )$/;"	f	class:tinyxml2::XMLNode
UnsignedAttribute	utility/tinyxml2.h	/^    unsigned UnsignedAttribute( const char* name ) const {$/;"	f	class:tinyxml2::XMLElement
UnsignedValue	utility/tinyxml2.h	/^    unsigned UnsignedValue() const			{$/;"	f	class:tinyxml2::XMLAttribute
Untracked	utility/tinyxml2.h	/^    int Untracked() const {$/;"	f	class:tinyxml2::MemPoolT
UpdateInput	pressure/VCycleMG.cpp	/^void VCycleMG::UpdateInput(Field *out, Field *b, bool sync) {$/;"	f	class:VCycleMG
Utility	utility/Utility.cpp	/^namespace Utility {$/;"	n	file:
Utility	utility/Utility.h	/^namespace Utility {$/;"	n
VCycleMG	pressure/VCycleMG.cpp	/^VCycleMG::VCycleMG(Field *out, Field *b) {$/;"	f	class:VCycleMG
VCycleMG	pressure/VCycleMG.h	/^class VCycleMG: public IPressure{$/;"	c
VCycleMG	solver/SolverSelection.h	/^    inline static const std::string VCycleMG = "VCycleMG";$/;"	m	struct:PressureMethods
VCycleMultigrid	pressure/VCycleMG.cpp	/^void VCycleMG::VCycleMultigrid(Field *out, bool sync) {$/;"	f	class:VCycleMG
VISITWRITER_H_	visualisation/visit_writer.h	40;"	d
VISIT_HEXAHEDRON	visualisation/visit_writer.h	175;"	d
VISIT_LINE	visualisation/visit_writer.h	171;"	d
VISIT_PYRAMID	visualisation/visit_writer.h	177;"	d
VISIT_QUAD	visualisation/visit_writer.h	173;"	d
VISIT_TETRA	visualisation/visit_writer.h	174;"	d
VISIT_TRIANGLE	visualisation/visit_writer.h	172;"	d
VISIT_VERTEX	visualisation/visit_writer.h	170;"	d
VISIT_WEDGE	visualisation/visit_writer.h	176;"	d
VTKWriter	visualisation/VTKWriter.h	/^class VTKWriter {$/;"	c
Value	utility/tinyxml2.cpp	/^const char* XMLAttribute::Value() const $/;"	f	class:tinyxml2::XMLAttribute
Value	utility/tinyxml2.cpp	/^const char* XMLNode::Value() const $/;"	f	class:tinyxml2::XMLNode
Visit	utility/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLComment& comment )$/;"	f	class:tinyxml2::XMLPrinter
Visit	utility/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLDeclaration& declaration )$/;"	f	class:tinyxml2::XMLPrinter
Visit	utility/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLText& text )$/;"	f	class:tinyxml2::XMLPrinter
Visit	utility/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLUnknown& unknown )$/;"	f	class:tinyxml2::XMLPrinter
Visit	utility/tinyxml2.h	/^    virtual bool Visit( const XMLComment& \/*comment*\/ )				{$/;"	f	class:tinyxml2::XMLVisitor
Visit	utility/tinyxml2.h	/^    virtual bool Visit( const XMLDeclaration& \/*declaration*\/ )		{$/;"	f	class:tinyxml2::XMLVisitor
Visit	utility/tinyxml2.h	/^    virtual bool Visit( const XMLText& \/*text*\/ )					{$/;"	f	class:tinyxml2::XMLVisitor
Visit	utility/tinyxml2.h	/^    virtual bool Visit( const XMLUnknown& \/*unknown*\/ )				{$/;"	f	class:tinyxml2::XMLVisitor
VisitEnter	utility/tinyxml2.cpp	/^bool XMLPrinter::VisitEnter( const XMLDocument& doc )$/;"	f	class:tinyxml2::XMLPrinter
VisitEnter	utility/tinyxml2.cpp	/^bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )$/;"	f	class:tinyxml2::XMLPrinter
VisitEnter	utility/tinyxml2.h	/^    virtual bool VisitEnter( const XMLDocument& \/*doc*\/ )			{$/;"	f	class:tinyxml2::XMLVisitor
VisitEnter	utility/tinyxml2.h	/^    virtual bool VisitEnter( const XMLElement& \/*element*\/, const XMLAttribute* \/*firstAttribute*\/ )	{$/;"	f	class:tinyxml2::XMLVisitor
VisitExit	utility/tinyxml2.cpp	/^bool XMLPrinter::VisitExit( const XMLElement& element )$/;"	f	class:tinyxml2::XMLPrinter
VisitExit	utility/tinyxml2.h	/^    virtual bool VisitExit( const XMLDocument& \/*doc*\/ )			{$/;"	f	class:tinyxml2::XMLPrinter
VisitExit	utility/tinyxml2.h	/^    virtual bool VisitExit( const XMLDocument& \/*doc*\/ )			{$/;"	f	class:tinyxml2::XMLVisitor
VisitExit	utility/tinyxml2.h	/^    virtual bool VisitExit( const XMLElement& \/*element*\/ )			{$/;"	f	class:tinyxml2::XMLVisitor
Visual	visualisation/Visual.cpp	/^Visual::Visual(Solution *solution) {$/;"	f	class:Visual
Visual	visualisation/Visual.h	/^class Visual {$/;"	c
Vortex	Functions.cpp	/^    void Vortex(Field *outx, Field *outy, Field *outz, Field *outp) {$/;"	f	namespace:Functions
Vortex	Functions.cpp	/^const std::string FunctionNames::Vortex = "Vortex";$/;"	m	class:FunctionNames	file:
Vortex	Functions.h	/^    static const std::string Vortex;$/;"	m	struct:FunctionNames
Vortex	adaption/Vortex.cpp	/^Vortex::Vortex(FieldController *field_controller) {$/;"	f	class:Vortex
Vortex	adaption/Vortex.h	/^class Vortex : public IAdaptionFunction {$/;"	c
VortexY	Functions.cpp	/^    void VortexY(Field *outx, Field *outy, Field *outz, Field *outp) {$/;"	f	namespace:Functions
VortexY	Functions.cpp	/^const std::string FunctionNames::VortexY = "VortexY";$/;"	m	class:FunctionNames	file:
VortexY	Functions.h	/^    static const std::string VortexY;$/;"	m	struct:FunctionNames
Whitespace	utility/tinyxml2.h	/^enum Whitespace {$/;"	g	namespace:tinyxml2
WhitespaceMode	utility/tinyxml2.h	/^    Whitespace WhitespaceMode() const	{$/;"	f	class:tinyxml2::XMLDocument
XMLAttribute	utility/tinyxml2.h	/^    XMLAttribute() : _next( 0 ), _memPool( 0 ) {}$/;"	f	class:tinyxml2::XMLAttribute
XMLAttribute	utility/tinyxml2.h	/^class TINYXML2_LIB XMLAttribute$/;"	c	namespace:tinyxml2
XMLComment	utility/tinyxml2.cpp	/^XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )$/;"	f	class:tinyxml2::XMLComment
XMLComment	utility/tinyxml2.h	/^class TINYXML2_LIB XMLComment : public XMLNode$/;"	c	namespace:tinyxml2
XMLConstHandle	utility/tinyxml2.h	/^    XMLConstHandle( const XMLConstHandle& ref )										{$/;"	f	class:tinyxml2::XMLConstHandle
XMLConstHandle	utility/tinyxml2.h	/^    XMLConstHandle( const XMLNode& node )											{$/;"	f	class:tinyxml2::XMLConstHandle
XMLConstHandle	utility/tinyxml2.h	/^    XMLConstHandle( const XMLNode* node )											{$/;"	f	class:tinyxml2::XMLConstHandle
XMLConstHandle	utility/tinyxml2.h	/^class TINYXML2_LIB XMLConstHandle$/;"	c	namespace:tinyxml2
XMLDeclaration	utility/tinyxml2.cpp	/^XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )$/;"	f	class:tinyxml2::XMLDeclaration
XMLDeclaration	utility/tinyxml2.h	/^class TINYXML2_LIB XMLDeclaration : public XMLNode$/;"	c	namespace:tinyxml2
XMLDocument	utility/tinyxml2.cpp	/^XMLDocument::XMLDocument( bool processEntities, Whitespace whitespace ) :$/;"	f	class:tinyxml2::XMLDocument
XMLDocument	utility/tinyxml2.h	/^class TINYXML2_LIB XMLDocument : public XMLNode$/;"	c	namespace:tinyxml2
XMLElement	utility/tinyxml2.cpp	/^XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),$/;"	f	class:tinyxml2::XMLElement
XMLElement	utility/tinyxml2.h	/^class TINYXML2_LIB XMLElement : public XMLNode$/;"	c	namespace:tinyxml2
XMLError	utility/tinyxml2.h	/^enum XMLError {$/;"	g	namespace:tinyxml2
XMLHandle	utility/tinyxml2.h	/^    XMLHandle( XMLNode& node )												{$/;"	f	class:tinyxml2::XMLHandle
XMLHandle	utility/tinyxml2.h	/^    XMLHandle( XMLNode* node )												{$/;"	f	class:tinyxml2::XMLHandle
XMLHandle	utility/tinyxml2.h	/^    XMLHandle( const XMLHandle& ref )										{$/;"	f	class:tinyxml2::XMLHandle
XMLHandle	utility/tinyxml2.h	/^class TINYXML2_LIB XMLHandle$/;"	c	namespace:tinyxml2
XMLNode	utility/tinyxml2.cpp	/^XMLNode::XMLNode( XMLDocument* doc ) :$/;"	f	class:tinyxml2::XMLNode
XMLNode	utility/tinyxml2.h	/^class TINYXML2_LIB XMLNode$/;"	c	namespace:tinyxml2
XMLPrinter	utility/tinyxml2.cpp	/^XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :$/;"	f	class:tinyxml2::XMLPrinter
XMLPrinter	utility/tinyxml2.h	/^class TINYXML2_LIB XMLPrinter : public XMLVisitor$/;"	c	namespace:tinyxml2
XMLText	utility/tinyxml2.h	/^    XMLText( XMLDocument* doc )	: XMLNode( doc ), _isCData( false )	{}$/;"	f	class:tinyxml2::XMLText
XMLText	utility/tinyxml2.h	/^class TINYXML2_LIB XMLText : public XMLNode$/;"	c	namespace:tinyxml2
XMLUnknown	utility/tinyxml2.cpp	/^XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )$/;"	f	class:tinyxml2::XMLUnknown
XMLUnknown	utility/tinyxml2.h	/^class TINYXML2_LIB XMLUnknown : public XMLNode$/;"	c	namespace:tinyxml2
XMLUtil	utility/tinyxml2.h	/^class XMLUtil$/;"	c	namespace:tinyxml2
XMLVisitor	utility/tinyxml2.h	/^class TINYXML2_LIB XMLVisitor$/;"	c	namespace:tinyxml2
XML_CAN_NOT_CONVERT_TEXT	utility/tinyxml2.h	/^    XML_CAN_NOT_CONVERT_TEXT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_COUNT	utility/tinyxml2.h	/^	XML_ERROR_COUNT$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_ELEMENT_MISMATCH	utility/tinyxml2.h	/^    XML_ERROR_ELEMENT_MISMATCH,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_EMPTY_DOCUMENT	utility/tinyxml2.h	/^    XML_ERROR_EMPTY_DOCUMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_FILE_COULD_NOT_BE_OPENED	utility/tinyxml2.h	/^    XML_ERROR_FILE_COULD_NOT_BE_OPENED,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_FILE_NOT_FOUND	utility/tinyxml2.h	/^    XML_ERROR_FILE_NOT_FOUND,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_FILE_READ_ERROR	utility/tinyxml2.h	/^    XML_ERROR_FILE_READ_ERROR,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_IDENTIFYING_TAG	utility/tinyxml2.h	/^    XML_ERROR_IDENTIFYING_TAG,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_MISMATCHED_ELEMENT	utility/tinyxml2.h	/^    XML_ERROR_MISMATCHED_ELEMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING	utility/tinyxml2.h	/^    XML_ERROR_PARSING,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_ATTRIBUTE	utility/tinyxml2.h	/^    XML_ERROR_PARSING_ATTRIBUTE,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_CDATA	utility/tinyxml2.h	/^    XML_ERROR_PARSING_CDATA,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_COMMENT	utility/tinyxml2.h	/^    XML_ERROR_PARSING_COMMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_DECLARATION	utility/tinyxml2.h	/^    XML_ERROR_PARSING_DECLARATION,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_ELEMENT	utility/tinyxml2.h	/^    XML_ERROR_PARSING_ELEMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_TEXT	utility/tinyxml2.h	/^    XML_ERROR_PARSING_TEXT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_UNKNOWN	utility/tinyxml2.h	/^    XML_ERROR_PARSING_UNKNOWN,$/;"	e	enum:tinyxml2::XMLError
XML_FALSE	utility/GlobalMacrosTypes.h	85;"	d
XML_NO_ATTRIBUTE	utility/tinyxml2.h	/^    XML_NO_ATTRIBUTE,$/;"	e	enum:tinyxml2::XMLError
XML_NO_ERROR	utility/tinyxml2.h	/^    XML_NO_ERROR = 0,$/;"	e	enum:tinyxml2::XMLError
XML_NO_TEXT_NODE	utility/tinyxml2.h	/^    XML_NO_TEXT_NODE,$/;"	e	enum:tinyxml2::XMLError
XML_SUCCESS	utility/tinyxml2.h	/^    XML_SUCCESS = 0,$/;"	e	enum:tinyxml2::XMLError
XML_TRUE	utility/GlobalMacrosTypes.h	84;"	d
XML_WRONG_ATTRIBUTE_TYPE	utility/tinyxml2.h	/^    XML_WRONG_ATTRIBUTE_TYPE,$/;"	e	enum:tinyxml2::XMLError
YES	adaption/Adaption.h	/^    NO = 0, UNKNOWN = 1, YES = 2$/;"	m	class:ADTypes
Zero	Functions.cpp	/^    void Zero(Field *field, size_t *arr_idx, size_t arr_idx_size) {$/;"	f	namespace:Functions
Zero	Functions.cpp	/^const std::string FunctionNames::Zero = "Zero";$/;"	m	class:FunctionNames	file:
Zero	Functions.h	/^    static const std::string Zero;$/;"	m	struct:FunctionNames
Zero	adaption/Vortex.cpp	/^void Vortex::Zero(size_t *arr_idx, size_t arr_idx_size) {$/;"	f	class:Vortex
Zero	solver/SolverSelection.h	/^    inline static const std::string Zero = "Zero";$/;"	m	struct:SourceMethods
Zero	source/Zero.h	/^class Zero: public ISourceFunction {$/;"	c
_allocated	utility/tinyxml2.h	/^    int _allocated;		\/\/ objects allocated$/;"	m	class:tinyxml2::DynArray
_attributePool	utility/tinyxml2.h	/^    MemPoolT< sizeof(XMLAttribute) > _attributePool;$/;"	m	class:tinyxml2::XMLDocument
_blockPtrs	utility/tinyxml2.h	/^    DynArray< Block*, 10 > _blockPtrs;$/;"	m	class:tinyxml2::MemPoolT
_buffer	utility/tinyxml2.h	/^    DynArray< char, 20 > _buffer;$/;"	m	class:tinyxml2::XMLPrinter
_charBuffer	utility/tinyxml2.h	/^    char*       _charBuffer;$/;"	m	class:tinyxml2::XMLDocument
_closingType	utility/tinyxml2.h	/^    int _closingType;$/;"	m	class:tinyxml2::XMLElement
_commentPool	utility/tinyxml2.h	/^    MemPoolT< sizeof(XMLComment) >	 _commentPool;$/;"	m	class:tinyxml2::XMLDocument
_compactMode	utility/tinyxml2.h	/^	bool _compactMode;$/;"	m	class:tinyxml2::XMLPrinter
_currentAllocs	utility/tinyxml2.h	/^    int _currentAllocs;$/;"	m	class:tinyxml2::MemPoolT
_depth	utility/tinyxml2.h	/^    int _depth;$/;"	m	class:tinyxml2::XMLPrinter
_document	utility/tinyxml2.h	/^    XMLDocument*	_document;$/;"	m	class:tinyxml2::XMLNode
_elementJustOpened	utility/tinyxml2.h	/^    bool _elementJustOpened;$/;"	m	class:tinyxml2::XMLPrinter
_elementPool	utility/tinyxml2.h	/^    MemPoolT< sizeof(XMLElement) >	 _elementPool;$/;"	m	class:tinyxml2::XMLDocument
_end	utility/tinyxml2.h	/^    char*   _end;$/;"	m	class:tinyxml2::StrPair
_entityFlag	utility/tinyxml2.h	/^    bool _entityFlag[ENTITY_RANGE];$/;"	m	class:tinyxml2::XMLPrinter
_errorID	utility/tinyxml2.h	/^    XMLError    _errorID;$/;"	m	class:tinyxml2::XMLDocument
_errorNames	utility/tinyxml2.cpp	/^const char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {$/;"	m	class:tinyxml2::XMLDocument	file:
_errorNames	utility/tinyxml2.h	/^	static const char* _errorNames[XML_ERROR_COUNT];$/;"	m	class:tinyxml2::XMLDocument
_errorStr1	utility/tinyxml2.h	/^    const char* _errorStr1;$/;"	m	class:tinyxml2::XMLDocument
_errorStr2	utility/tinyxml2.h	/^    const char* _errorStr2;$/;"	m	class:tinyxml2::XMLDocument
_firstChild	utility/tinyxml2.h	/^    XMLNode*		_firstChild;$/;"	m	class:tinyxml2::XMLNode
_firstElement	utility/tinyxml2.h	/^    bool _firstElement;$/;"	m	class:tinyxml2::XMLPrinter
_flags	utility/tinyxml2.h	/^    int     _flags;$/;"	m	class:tinyxml2::StrPair
_fp	utility/tinyxml2.h	/^    FILE* _fp;$/;"	m	class:tinyxml2::XMLPrinter
_isCData	utility/tinyxml2.h	/^    bool _isCData;$/;"	m	class:tinyxml2::XMLText
_lastChild	utility/tinyxml2.h	/^    XMLNode*		_lastChild;$/;"	m	class:tinyxml2::XMLNode
_maxAllocs	utility/tinyxml2.h	/^    int _maxAllocs;$/;"	m	class:tinyxml2::MemPoolT
_mem	utility/tinyxml2.h	/^    T*  _mem;$/;"	m	class:tinyxml2::DynArray
_memPool	utility/tinyxml2.h	/^    MemPool*		_memPool;$/;"	m	class:tinyxml2::XMLNode
_memPool	utility/tinyxml2.h	/^    MemPool*        _memPool;$/;"	m	class:tinyxml2::XMLAttribute
_nAllocs	utility/tinyxml2.h	/^    int _nAllocs;$/;"	m	class:tinyxml2::MemPoolT
_nUntracked	utility/tinyxml2.h	/^    int _nUntracked;$/;"	m	class:tinyxml2::MemPoolT
_name	utility/tinyxml2.h	/^    mutable StrPair _name;$/;"	m	class:tinyxml2::XMLAttribute
_next	utility/tinyxml2.h	/^    XMLAttribute*   _next;$/;"	m	class:tinyxml2::XMLAttribute
_next	utility/tinyxml2.h	/^    XMLNode*		_next;$/;"	m	class:tinyxml2::XMLNode
_node	utility/tinyxml2.h	/^    XMLNode* _node;$/;"	m	class:tinyxml2::XMLHandle
_node	utility/tinyxml2.h	/^    const XMLNode* _node;$/;"	m	class:tinyxml2::XMLConstHandle
_parent	utility/tinyxml2.h	/^    XMLNode*		_parent;$/;"	m	class:tinyxml2::XMLNode
_pool	utility/tinyxml2.h	/^    T   _pool[INITIAL_SIZE];$/;"	m	class:tinyxml2::DynArray
_prev	utility/tinyxml2.h	/^    XMLNode*		_prev;$/;"	m	class:tinyxml2::XMLNode
_processEntities	utility/tinyxml2.h	/^    bool        _processEntities;$/;"	m	class:tinyxml2::XMLDocument
_processEntities	utility/tinyxml2.h	/^    bool _processEntities;$/;"	m	class:tinyxml2::XMLPrinter
_restrictedEntityFlag	utility/tinyxml2.h	/^    bool _restrictedEntityFlag[ENTITY_RANGE];$/;"	m	class:tinyxml2::XMLPrinter
_root	utility/tinyxml2.h	/^    Chunk* _root;$/;"	m	class:tinyxml2::MemPoolT
_rootAttribute	utility/tinyxml2.h	/^    XMLAttribute* _rootAttribute;$/;"	m	class:tinyxml2::XMLElement
_size	utility/tinyxml2.h	/^    int _size;			\/\/ number objects in use$/;"	m	class:tinyxml2::DynArray
_stack	utility/tinyxml2.h	/^    DynArray< const char*, 10 > _stack;$/;"	m	class:tinyxml2::XMLPrinter
_start	utility/tinyxml2.h	/^    char*   _start;$/;"	m	class:tinyxml2::StrPair
_textDepth	utility/tinyxml2.h	/^    int _textDepth;$/;"	m	class:tinyxml2::XMLPrinter
_textPool	utility/tinyxml2.h	/^    MemPoolT< sizeof(XMLText) >		 _textPool;$/;"	m	class:tinyxml2::XMLDocument
_value	utility/tinyxml2.h	/^    mutable StrPair	_value;$/;"	m	class:tinyxml2::XMLNode
_value	utility/tinyxml2.h	/^    mutable StrPair _value;$/;"	m	class:tinyxml2::XMLAttribute
_whitespace	utility/tinyxml2.h	/^    Whitespace  _whitespace;$/;"	m	class:tinyxml2::XMLDocument
_writeBOM	utility/tinyxml2.h	/^    bool        _writeBOM;$/;"	m	class:tinyxml2::XMLDocument
adaptXDirection	adaption/Layers.cpp	/^void Layers::adaptXDirection(real checkValue, size_t no_buffer_cell, long *p_shift_x1, long *p_shift_x2) {$/;"	f	class:Layers
adaptXDirection_serial	adaption/Layers.cpp	/^void Layers::adaptXDirection_serial(real checkValue, size_t no_buffer_cell, long *p_shift_x1, long *p_shift_x2) {$/;"	f	class:Layers
adapt_x_direction	adaption/Adaption.cpp	/^bool Adaption::adapt_x_direction(const real *f, real check_value, size_t no_buffer_cell, real threshold, long *p_shift_x1, long *p_shift_x2, size_t minimal, bool reduce) {$/;"	f	class:Adaption
adapt_x_direction_serial	adaption/Adaption.cpp	/^bool Adaption::adapt_x_direction_serial(const real *f, real check_value, size_t no_buffer_cell, real threshold, long *p_shift_x1, long *p_shift_x2, size_t minimal, bool reduce) {$/;"	f	class:Adaption
adapt_y_direction	adaption/Adaption.cpp	/^bool Adaption::adapt_y_direction(const real *f, real check_value, size_t no_buffer_cell, real threshold, long *p_shift_x1, long *p_shift_x2, size_t minimal, bool reduce) {$/;"	f	class:Adaption
adapt_y_direction_serial	adaption/Adaption.cpp	/^bool Adaption::adapt_y_direction_serial(const real *f, real check_value, size_t no_buffer_cell, real threshold, long *p_shift_x1, long *p_shift_x2, size_t minimal, bool reduce) {$/;"	f	class:Adaption
addBoundaryCondition	boundary/BoundaryData.cpp	/^void BoundaryData::addBoundaryCondition(const std::vector<Patch> &patches, real value, BoundaryCondition boundaryCondition) {$/;"	f	class:BoundaryData
addBoundaryData	boundary/BoundaryDataController.cpp	/^void BoundaryDataController::addBoundaryData(tinyxml2::XMLElement *xmlElement) {$/;"	f	class:BoundaryDataController
addMGLists	boundary/Multigrid.cpp	/^void Multigrid::addMGLists() {$/;"	f	class:Multigrid
add_source	source/ExplicitEulerSource.cpp	/^void ExplicitEulerSource::add_source(Field *out, Field *S, bool sync) {$/;"	f	class:ExplicitEulerSource
add_source	source/ExplicitEulerSource.cpp	/^void ExplicitEulerSource::add_source(Field *out_x, Field *out_y, Field *out_z, Field *S_x, Field *S_y, Field *S_z, bool sync) {$/;"	f	class:ExplicitEulerSource
adv	solver/AdvectionDiffusionSolver.h	/^    IAdvection *adv;$/;"	m	class:AdvectionDiffusionSolver
adv	solver/AdvectionSolver.h	/^    IAdvection *adv;$/;"	m	class:AdvectionSolver
adv_con	solver/NSTempConSolver.h	/^    IAdvection *adv_con;$/;"	m	class:NSTempConSolver
adv_con	solver/NSTempTurbConSolver.h	/^    IAdvection *adv_con;$/;"	m	class:NSTempTurbConSolver
adv_temp	solver/NSTempConSolver.h	/^    IAdvection *adv_temp;$/;"	m	class:NSTempConSolver
adv_temp	solver/NSTempSolver.h	/^    IAdvection *adv_temp;$/;"	m	class:NSTempSolver
adv_temp	solver/NSTempTurbConSolver.h	/^    IAdvection *adv_temp;$/;"	m	class:NSTempTurbConSolver
adv_temp	solver/NSTempTurbSolver.h	/^    IAdvection *adv_temp;$/;"	m	class:NSTempTurbSolver
adv_vel	solver/NSSolver.h	/^    IAdvection *adv_vel;$/;"	m	class:NSSolver
adv_vel	solver/NSTempConSolver.h	/^    IAdvection *adv_vel;$/;"	m	class:NSTempConSolver
adv_vel	solver/NSTempSolver.h	/^    IAdvection *adv_vel;$/;"	m	class:NSTempSolver
adv_vel	solver/NSTempTurbConSolver.h	/^    IAdvection *adv_vel;$/;"	m	class:NSTempTurbConSolver
adv_vel	solver/NSTempTurbSolver.h	/^    IAdvection *adv_vel;$/;"	m	class:NSTempTurbSolver
adv_vel	solver/NSTurbSolver.h	/^    IAdvection *adv_vel;$/;"	m	class:NSTurbSolver
advect	advection/SLAdvect.cpp	/^void SLAdvect::advect(Field *out, Field *in, const Field *u_vel, const Field *v_vel, const Field *w_vel, bool sync) {$/;"	f	class:SLAdvect
analyse	analysis/Analysis.cpp	/^void Analysis::analyse(FieldController *field_controller, real t) {$/;"	f	class:Analysis
applyBoundary	boundary/BoundaryController.cpp	/^void BoundaryController::applyBoundary(real *d, FieldType f, bool sync) {$/;"	f	class:BoundaryController
applyBoundary	boundary/BoundaryController.cpp	/^void BoundaryController::applyBoundary(real *d, size_t level, FieldType f, bool sync) {$/;"	f	class:BoundaryController
applyBoundaryCondition	boundary/BoundaryDataController.cpp	/^void BoundaryDataController::applyBoundaryCondition(real *data, size_t **indexFields, size_t *patch_start, size_t *patch_end, FieldType fieldType, size_t level, bool sync) {$/;"	f	class:BoundaryDataController
applyBoundaryCondition	boundary/Multigrid.cpp	/^void Multigrid::applyBoundaryCondition(real *d, size_t level, FieldType f, bool sync) {$/;"	f	class:Multigrid
applyBoundaryConditionObstacle	boundary/BoundaryDataController.cpp	/^void BoundaryDataController::applyBoundaryConditionObstacle(real *data, size_t **indexFields, size_t *patch_start, size_t *patch_end, FieldType fieldType, size_t level, size_t id, bool sync) {$/;"	f	class:BoundaryDataController
applyBoundaryConditions	boundary/Surface.cpp	/^void Surface::applyBoundaryConditions(real *dataField, FieldType fieldType, size_t level, bool sync) {$/;"	f	class:Surface
applyChanges	adaption/Adaption.cpp	/^void Adaption::applyChanges() {$/;"	f	class:Adaption
apply_boundary_condition	boundaryCondition/DomainBoundary.cpp	/^    void apply_boundary_condition(real *data_field, const size_t *d_patch, size_t patch_start, size_t patch_end, size_t level, int8_t sign_reference_index, size_t reference_index, real value, int8_t sign) {$/;"	f	namespace:DomainBoundary::__anon1
apply_boundary_condition	boundaryCondition/DomainBoundary.cpp	/^void apply_boundary_condition(real *data_field, size_t **index_fields, const size_t *patch_starts, const size_t *patch_ends, size_t level, BoundaryData *boundary_data, bool sync) {$/;"	f	namespace:DomainBoundary
apply_boundary_condition	boundaryCondition/ObstacleBoundary.cpp	/^    void apply_boundary_condition(real *data_field, const size_t *d_patch, size_t patch_start, size_t patch_end, size_t level, int8_t sign_reference_index, size_t reference_index, real value, int8_t sign) {$/;"	f	namespace:ObstacleBoundary::__anon2
apply_boundary_condition	boundaryCondition/ObstacleBoundary.cpp	/^void apply_boundary_condition(real *data, size_t **index_fields, const size_t *patch_starts, const size_t *patch_ends, size_t level, BoundaryData *boundary_data, size_t id, bool sync) {$/;"	f	namespace:ObstacleBoundary
apply_changes	adaption/Layers.cpp	/^void Layers::apply_changes(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) {$/;"	f	class:Layers
apply_changes	adaption/Vortex.cpp	/^void Vortex::apply_changes(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) {$/;"	f	class:Vortex
apply_dirichlet	boundaryCondition/DomainBoundary.cpp	/^    void apply_dirichlet(real *data_field, size_t *d_patch, Patch patch, size_t patch_start, size_t patch_end, size_t level, real value) {$/;"	f	namespace:DomainBoundary::__anon1
apply_dirichlet	boundaryCondition/ObstacleBoundary.cpp	/^    void apply_dirichlet(real *data_field, size_t *d_patch, Patch p, size_t patch_start, size_t patch_end, size_t level, real value) {$/;"	f	namespace:ObstacleBoundary::__anon2
apply_neumann	boundaryCondition/DomainBoundary.cpp	/^    void apply_neumann(real *data_field, size_t *d_patch, Patch patch, size_t patch_start, size_t patch_end, size_t level, real value) {$/;"	f	namespace:DomainBoundary::__anon1
apply_neumann	boundaryCondition/ObstacleBoundary.cpp	/^    void apply_neumann(real *data_field, size_t *d_patch, Patch p, size_t patch_start, size_t patch_end, size_t level, real value) {$/;"	f	namespace:ObstacleBoundary::__anon2
apply_periodic	boundaryCondition/DomainBoundary.cpp	/^    void apply_periodic(real *data_field, size_t *d_patch, Patch patch, size_t patch_start, size_t patch_end, size_t level) {$/;"	f	namespace:DomainBoundary::__anon1
apply_periodic	boundaryCondition/ObstacleBoundary.cpp	/^    void apply_periodic(real *data_field, size_t *d_patch, Patch p, size_t patch_start, size_t patch_end, size_t level, size_t id) {$/;"	f	namespace:ObstacleBoundary::__anon2
beltrami	analysis/Solution.cpp	/^void Solution::beltrami(const real t) {$/;"	f	class:Solution
boundaryCells	boundary/Boundary.cpp	/^void Boundary::boundaryCells() {$/;"	f	class:Boundary
buoyancy_force	interfaces/ISource.cpp	/^void ISource::buoyancy_force(Field *out, const Field *in, const Field *in_temperature_ambient, bool sync) {$/;"	f	class:ISource
buoyancy_mms	analysis/Solution.cpp	/^void Solution::buoyancy_mms(const real t) {$/;"	f	class:Solution
calcObstacles	boundary/Multigrid.cpp	/^void Multigrid::calcObstacles(Obstacle **obstacleList) {$/;"	f	class:Multigrid
calcSurfaces	boundary/Multigrid.cpp	/^void Multigrid::calcSurfaces(Surface **surfaceList) {$/;"	f	class:Multigrid
calc_CFL	analysis/Analysis.cpp	/^real Analysis::calc_CFL(Field *u, Field *v, Field *w, real dt) {$/;"	f	class:Analysis
calc_L2_norm_mid_point	analysis/Analysis.cpp	/^void Analysis::calc_L2_norm_mid_point(FieldController *field_controller, real t, real *sum) {$/;"	f	class:Analysis
calc_MG_values	Domain.cpp	/^void Domain::calc_MG_values() {$/;"	f	class:Domain
calc_RMS_error	analysis/Analysis.cpp	/^void Analysis::calc_RMS_error(real sum_u, real sum_p, real sum_T) {$/;"	f	class:Analysis
calc_absolute_spatial_error	analysis/Analysis.cpp	/^real Analysis::calc_absolute_spatial_error(read_ptr num, read_ptr ana) {$/;"	f	class:Analysis
calc_analytical_solution	analysis/Solution.cpp	/^void Solution::calc_analytical_solution(real t) {$/;"	f	class:Solution
calc_new_coord	Domain.cpp	/^real Domain::calc_new_coord(real oldCoord, long shift, real cell_width) {$/;"	f	class:Domain
calc_relative_spatial_error	analysis/Analysis.cpp	/^real Analysis::calc_relative_spatial_error(read_ptr num, read_ptr ana) {$/;"	f	class:Analysis
call_random	solver/SolverController.cpp	/^void SolverController::call_random(Field *field) {$/;"	f	class:SolverController
callfopen	utility/tinyxml2.cpp	/^static FILE* callfopen( const char* filepath, const char* mode )$/;"	f	namespace:tinyxml2
check_time_step_VN	analysis/Analysis.cpp	/^bool Analysis::check_time_step_VN(Field *u, real dt) {$/;"	f	class:Analysis
chunk	utility/tinyxml2.h	/^        Chunk chunk[COUNT];$/;"	m	struct:tinyxml2::MemPoolT::Block
clearLists	boundary/Boundary.cpp	/^void Boundary::clearLists(){$/;"	f	class:Boundary
close_file	visualisation/visit_writer.cpp	/^static void close_file(void)$/;"	f	file:
colored_gauss_seidel_stencil	diffusion/ColoredGaussSeidelDiffuse.cpp	/^void ColoredGaussSeidelDiffuse::colored_gauss_seidel_stencil(size_t i, size_t j, size_t k, real *out, real *b, const real alpha_x, const real alpha_y, const real alpha_z, const real dsign, const real beta, const real w, const size_t Nx, const size_t Ny) {$/;"	f	class:ColoredGaussSeidelDiffuse
colored_gauss_seidel_step	diffusion/ColoredGaussSeidelDiffuse.cpp	/^void ColoredGaussSeidelDiffuse::colored_gauss_seidel_step(Field *out, const Field *b, const real alpha_x, const real alpha_y, const real alpha_z, const real beta, const real dsign, const real w, bool sync) {$/;"	f	class:ColoredGaussSeidelDiffuse
colored_gauss_seidel_step	diffusion/ColoredGaussSeidelDiffuse.cpp	/^void ColoredGaussSeidelDiffuse::colored_gauss_seidel_step(Field *out, const Field *b, const real dsign, const real w, const real D, const Field *EV, const real dt, bool sync) {$/;"	f	class:ColoredGaussSeidelDiffuse
compare_solutions	analysis/Analysis.cpp	/^bool Analysis::compare_solutions(read_ptr num, read_ptr ana, FieldType type, real t) {$/;"	f	class:Analysis
control	boundary/Boundary.cpp	/^void Boundary::control(size_t size_obstacles) {$/;"	f	class:Boundary
control	boundary/Multigrid.cpp	/^void Multigrid::control() {$/;"	f	class:Multigrid
control	boundary/Obstacle.cpp	/^void Obstacle::control() {$/;"	f	class:Obstacle
control	solver/AdvectionDiffusionSolver.cpp	/^void AdvectionDiffusionSolver::control() {$/;"	f	class:AdvectionDiffusionSolver
control	solver/AdvectionSolver.cpp	/^void AdvectionSolver::control() {$/;"	f	class:AdvectionSolver
control	solver/DiffusionSolver.cpp	/^void DiffusionSolver::control() {$/;"	f	class:DiffusionSolver
control	solver/DiffusionTurbSolver.cpp	/^void DiffusionTurbSolver::control() {$/;"	f	class:DiffusionTurbSolver
control	solver/NSSolver.cpp	/^void NSSolver::control() {$/;"	f	class:NSSolver
control	solver/NSTempConSolver.cpp	/^void NSTempConSolver::control() {$/;"	f	class:NSTempConSolver
control	solver/NSTempSolver.cpp	/^void NSTempSolver::control() {$/;"	f	class:NSTempSolver
control	solver/NSTempTurbConSolver.cpp	/^void NSTempTurbConSolver::control() {$/;"	f	class:NSTempTurbConSolver
control	solver/NSTempTurbSolver.cpp	/^void NSTempTurbSolver::control() {$/;"	f	class:NSTempTurbSolver
control	solver/NSTurbSolver.cpp	/^void NSTurbSolver::control() {$/;"	f	class:NSTurbSolver
control	solver/PressureSolver.cpp	/^void PressureSolver::control() {$/;"	f	class:PressureSolver
copy_data	field/Field.h	/^    void copy_data(const Field &other) {$/;"	f	class:Field
copyin	field/Field.h	/^    void copyin() {$/;"	f	class:Field
couple_scalar	field/FieldController.cpp	/^void FieldController::couple_scalar(const Field *a, Field *a0, Field *a_tmp, bool sync) {$/;"	f	class:FieldController
couple_vector	field/FieldController.cpp	/^void FieldController::couple_vector(const Field *a, Field *a0, Field *a_tmp, const Field *b, Field *b0, Field *b_tmp, const Field *c, Field *c0, Field *c_tmp, bool sync) {$/;"	f	class:FieldController
createObstacle	boundary/Obstacle.cpp	/^void Obstacle::createObstacle(size_t Nx, size_t Ny) {$/;"	f	class:Obstacle
createSurface	boundary/Surface.cpp	/^void Surface::createSurface(size_t Nx, size_t Ny) {$/;"	f	class:Surface
create_filename	visualisation/Visual.cpp	/^std::string Visual::create_filename(std::string filename, int counter, bool analytical) {$/;"	f	class:Visual
create_logger	utility/Utility.cpp	/^std::shared_ptr<spdlog::logger> create_logger(std::string logger_name) {$/;"	f	namespace:Utility
create_spatial_values	source/GaussFunction.cpp	/^void GaussFunction::create_spatial_values(real HRR, real cp, real x0, real y0, real z0, real sigma_x, real sigma_y, real sigma_z) {$/;"	f	class:GaussFunction
csvPrepareAndWrite	visualisation/CSVWriter.cpp	/^void CSVWriter::csvPrepareAndWrite(const char *filename, real *u, real *v, real *w, real *p, real *T) {$/;"	f	class:CSVWriter
csvPrepareAndWrite	visualisation/CSVWriter.cpp	/^void CSVWriter::csvPrepareAndWrite(const char *filename, real *u, real *v, real *w, real *p, real *div, real *T, real *C, real *s, real *nu_t, real *S_T) {$/;"	f	class:CSVWriter
csv_write	visualisation/CSVWriter.cpp	/^void CSVWriter::csv_write(const char *filename, real **vars, int size_vars, const char **var_names) {$/;"	f	class:CSVWriter
cycles	pressure/VCycleMG.h	/^    int cycles;$/;"	m	class:VCycleMG
data	field/Field.h	/^    real *data;$/;"	m	class:Field
dataList	boundary/Surface.h	/^    std::vector<BoundaryData*> dataList;$/;"	m	class:Surface
delimiter	visualisation/CSVWriter.cpp	/^const static char delimiter = ',';$/;"	v	file:
dif	solver/AdvectionDiffusionSolver.h	/^    IDiffusion *dif;$/;"	m	class:AdvectionDiffusionSolver
dif	solver/DiffusionSolver.h	/^    IDiffusion *dif;$/;"	m	class:DiffusionSolver
dif	solver/DiffusionTurbSolver.h	/^    IDiffusion *dif;$/;"	m	class:DiffusionTurbSolver
dif_con	solver/NSTempConSolver.h	/^    IDiffusion *dif_con;$/;"	m	class:NSTempConSolver
dif_con	solver/NSTempTurbConSolver.h	/^    IDiffusion *dif_con;$/;"	m	class:NSTempTurbConSolver
dif_temp	solver/NSTempConSolver.h	/^    IDiffusion *dif_temp;$/;"	m	class:NSTempConSolver
dif_temp	solver/NSTempSolver.h	/^    IDiffusion *dif_temp;$/;"	m	class:NSTempSolver
dif_temp	solver/NSTempTurbConSolver.h	/^    IDiffusion *dif_temp;$/;"	m	class:NSTempTurbConSolver
dif_temp	solver/NSTempTurbSolver.h	/^    IDiffusion *dif_temp;$/;"	m	class:NSTempTurbSolver
dif_vel	solver/NSSolver.h	/^    IDiffusion *dif_vel;$/;"	m	class:NSSolver
dif_vel	solver/NSTempConSolver.h	/^    IDiffusion *dif_vel;$/;"	m	class:NSTempConSolver
dif_vel	solver/NSTempSolver.h	/^    IDiffusion *dif_vel;$/;"	m	class:NSTempSolver
dif_vel	solver/NSTempTurbConSolver.h	/^    IDiffusion *dif_vel;$/;"	m	class:NSTempTurbConSolver
dif_vel	solver/NSTempTurbSolver.h	/^    IDiffusion *dif_vel;$/;"	m	class:NSTempTurbSolver
dif_vel	solver/NSTurbSolver.h	/^    IDiffusion *dif_vel;$/;"	m	class:NSTurbSolver
diffuse	diffusion/ColoredGaussSeidelDiffuse.cpp	/^void ColoredGaussSeidelDiffuse::diffuse(Field *out, Field *in, const Field *b, const real D, bool sync) {$/;"	f	class:ColoredGaussSeidelDiffuse
diffuse	diffusion/ColoredGaussSeidelDiffuse.cpp	/^void ColoredGaussSeidelDiffuse::diffuse(Field *out, Field *in, const Field *b, const real D, const Field *EV, bool sync) {$/;"	f	class:ColoredGaussSeidelDiffuse
diffuse	diffusion/ExplicitDiffuse.cpp	/^void ExplicitDiffuse::diffuse(Field *out, Field *in, const Field *b, const real D, bool sync) {$/;"	f	class:ExplicitDiffuse
diffuse	diffusion/ExplicitDiffuse.cpp	/^void ExplicitDiffuse::diffuse(Field *out, Field *in, const Field *b, const real D, const Field *EV, bool sync) {$/;"	f	class:ExplicitDiffuse
diffuse	diffusion/JacobiDiffuse.cpp	/^void JacobiDiffuse::diffuse(Field *out, Field *in, const Field *b, const real D, bool sync) {$/;"	f	class:JacobiDiffuse
diffuse	diffusion/JacobiDiffuse.cpp	/^void JacobiDiffuse::diffuse(Field *out, Field *in, const Field *b, const real D, const Field *EV, bool sync) {$/;"	f	class:JacobiDiffuse
dissipate	interfaces/ISource.cpp	/^void ISource::dissipate(Field *out, const Field *in_u, const Field *in_v, const Field *in_w, bool sync) {$/;"	f	class:ISource
divergence	interfaces/IPressure.cpp	/^void IPressure::divergence(Field *out, const Field *in_x, const Field *in_y, const Field *in_z, bool sync) {$/;"	f	class:IPressure
do_step	solver/AdvectionDiffusionSolver.cpp	/^void AdvectionDiffusionSolver::do_step(real t, bool sync) {$/;"	f	class:AdvectionDiffusionSolver
do_step	solver/AdvectionSolver.cpp	/^void AdvectionSolver::do_step(real t, bool sync) {$/;"	f	class:AdvectionSolver
do_step	solver/DiffusionSolver.cpp	/^void DiffusionSolver::do_step(real t, bool sync) {$/;"	f	class:DiffusionSolver
do_step	solver/DiffusionTurbSolver.cpp	/^void DiffusionTurbSolver::do_step(real t, bool sync) {$/;"	f	class:DiffusionTurbSolver
do_step	solver/NSSolver.cpp	/^void NSSolver::do_step(real t, bool sync) {$/;"	f	class:NSSolver
do_step	solver/NSTempConSolver.cpp	/^void NSTempConSolver::do_step(real t, bool sync) {$/;"	f	class:NSTempConSolver
do_step	solver/NSTempSolver.cpp	/^void NSTempSolver::do_step(real t, bool sync) {$/;"	f	class:NSTempSolver
do_step	solver/NSTempTurbConSolver.cpp	/^void NSTempTurbConSolver::do_step(real t, bool sync) {$/;"	f	class:NSTempTurbConSolver
do_step	solver/NSTempTurbSolver.cpp	/^void NSTempTurbSolver::do_step(real t, bool sync) {$/;"	f	class:NSTempTurbSolver
do_step	solver/NSTurbSolver.cpp	/^void NSTurbSolver::do_step(real t, bool sync) {$/;"	f	class:NSTurbSolver
do_step	solver/PressureSolver.cpp	/^void PressureSolver::do_step(real t, bool sync) {$/;"	f	class:PressureSolver
doc	utility/Parameters.h	/^    tinyxml2::XMLDocument* doc;$/;"	m	class:Parameters
end_line	visualisation/visit_writer.cpp	/^static void end_line(void)$/;"	f	file:
ending	visualisation/CSVWriter.cpp	/^static std::string ending = ".csv";$/;"	v	file:
ending	visualisation/VTKWriter.cpp	/^static std::string ending = ".vtk";$/;"	v	file:
entities	utility/tinyxml2.cpp	/^static const Entity entities[NUM_ENTITIES] = {$/;"	m	namespace:tinyxml2	file:
err0	pressure/VCycleMG.h	/^    std::vector<Field*> err0;$/;"	m	class:VCycleMG
error1	pressure/VCycleMG.h	/^    std::vector<Field*> error1;$/;"	m	class:VCycleMG
exp_sinus_prod	analysis/Solution.cpp	/^void Solution::exp_sinus_prod(const real t) {$/;"	f	class:Solution
exp_sinus_sum	analysis/Solution.cpp	/^void Solution::exp_sinus_sum(const real t) {$/;"	f	class:Solution
expand_x_direction	adaption/Adaption.cpp	/^void Adaption::expand_x_direction(long shift, bool start, size_t *arr_idx_expansion, size_t len_e) {$/;"	f	class:Adaption
expand_y_direction	adaption/Adaption.cpp	/^void Adaption::expand_y_direction(long shift, bool start, size_t *arr_idx_expansion, size_t len_e) {$/;"	f	class:Adaption
extractData	adaption/Adaption.cpp	/^void Adaption::extractData(const std::string &filename) {$/;"	f	class:Adaption
extractData	adaption/Adaption.cpp	/^void Adaption::extractData(const std::string &filename, real height, real time) {$/;"	f	class:Adaption
field_T	field/FieldController.h	/^    Field *field_T;                  \/\/ temperature$/;"	m	class:FieldController
field_T0	field/FieldController.h	/^    Field *field_T0;$/;"	m	class:FieldController
field_T_ambient	field/FieldController.h	/^    Field *field_T_ambient;$/;"	m	class:FieldController
field_T_tmp	field/FieldController.h	/^    Field *field_T_tmp;$/;"	m	class:FieldController
field_concentration	field/FieldController.h	/^    Field *field_concentration;      \/\/ smoke concentration$/;"	m	class:FieldController
field_concentration0	field/FieldController.h	/^    Field *field_concentration0;$/;"	m	class:FieldController
field_concentration_tmp	field/FieldController.h	/^    Field *field_concentration_tmp;$/;"	m	class:FieldController
field_force_x	field/FieldController.h	/^    Field *field_force_x, *field_force_y, *field_force_z;    \/\/ sources$/;"	m	class:FieldController
field_force_y	field/FieldController.h	/^    Field *field_force_x, *field_force_y, *field_force_z;    \/\/ sources$/;"	m	class:FieldController
field_force_z	field/FieldController.h	/^    Field *field_force_x, *field_force_y, *field_force_z;    \/\/ sources$/;"	m	class:FieldController
field_gamma_t	field/FieldController.h	/^    Field *field_gamma_t;$/;"	m	class:FieldController
field_kappa_t	field/FieldController.h	/^    Field *field_kappa_t;$/;"	m	class:FieldController
field_nu_t	field/FieldController.h	/^    Field *field_nu_t;$/;"	m	class:FieldController
field_p	field/FieldController.h	/^    Field *field_p;                  \/\/ pressure$/;"	m	class:FieldController
field_p0	field/FieldController.h	/^    Field *field_p0;$/;"	m	class:FieldController
field_rhs	field/FieldController.h	/^    Field *field_rhs;$/;"	m	class:FieldController
field_source_T	field/FieldController.h	/^    Field *field_source_T;                \/\/ temperature$/;"	m	class:FieldController
field_source_concentration	field/FieldController.h	/^    Field *field_source_concentration;    \/\/ smoke concentration$/;"	m	class:FieldController
field_u	field/FieldController.h	/^    Field *field_u, *field_v, *field_w;          \/\/ velocities$/;"	m	class:FieldController
field_u0	field/FieldController.h	/^    Field *field_u0, *field_v0, *field_w0;$/;"	m	class:FieldController
field_u_tmp	field/FieldController.h	/^    Field *field_u_tmp, *field_v_tmp, *field_w_tmp;$/;"	m	class:FieldController
field_v	field/FieldController.h	/^    Field *field_u, *field_v, *field_w;          \/\/ velocities$/;"	m	class:FieldController
field_v0	field/FieldController.h	/^    Field *field_u0, *field_v0, *field_w0;$/;"	m	class:FieldController
field_v_tmp	field/FieldController.h	/^    Field *field_u_tmp, *field_v_tmp, *field_w_tmp;$/;"	m	class:FieldController
field_w	field/FieldController.h	/^    Field *field_u, *field_v, *field_w;          \/\/ velocities$/;"	m	class:FieldController
field_w0	field/FieldController.h	/^    Field *field_u0, *field_v0, *field_w0;$/;"	m	class:FieldController
field_w_tmp	field/FieldController.h	/^    Field *field_u_tmp, *field_v_tmp, *field_w_tmp;$/;"	m	class:FieldController
force_big_endian	visualisation/visit_writer.cpp	/^static void force_big_endian(unsigned char *bytes)$/;"	f	file:
force_source	solver/SolverController.cpp	/^void SolverController::force_source() {$/;"	f	class:SolverController
fp	visualisation/visit_writer.cpp	/^static FILE *fp = nullptr;$/;"	v	file:
func	adaption/Adaption.h	/^    IAdaptionFunction *func;$/;"	m	class:ADTypes::Adaption
gauss_bubble	analysis/Solution.cpp	/^void Solution::gauss_bubble(const real t) {$/;"	f	class:Solution
get	utility/Parameters.cpp	/^std::string Parameters::get(const std::string &raw_path) {$/;"	f	class:Parameters
getBoundaryBack	boundary/Boundary.h	/^    size_t* getBoundaryBack() {return m_boundaryBack;}$/;"	f	class:Boundary
getBoundaryBottom	boundary/Boundary.h	/^    size_t* getBoundaryBottom() {return m_boundaryBottom;}$/;"	f	class:Boundary
getBoundaryCondition	boundary/BoundaryData.h	/^    BoundaryCondition getBoundaryCondition(Patch p){ return m_boundaryConditions[p];};$/;"	f	class:BoundaryData
getBoundaryConditionName	boundary/BoundaryData.cpp	/^std::string BoundaryData::getBoundaryConditionName(BoundaryCondition bc) {$/;"	f	class:BoundaryData
getBoundaryFront	boundary/Boundary.h	/^    size_t* getBoundaryFront() {return m_boundaryFront;}$/;"	f	class:Boundary
getBoundaryLeft	boundary/Boundary.h	/^    size_t* getBoundaryLeft() {return m_boundaryLeft;}$/;"	f	class:Boundary
getBoundaryList	boundary/Boundary.h	/^    size_t* getBoundaryList() {return m_boundaryList;}$/;"	f	class:Boundary
getBoundaryList_level_joined	boundary/Multigrid.h	/^    size_t* getBoundaryList_level_joined() { return m_data_MG_bList_level_joined; };$/;"	f	class:Multigrid
getBoundaryList_level_joined_end	boundary/Multigrid.cpp	/^size_t Multigrid::getBoundaryList_level_joined_end(size_t level) {$/;"	f	class:Multigrid
getBoundaryList_level_joined_start	boundary/Multigrid.cpp	/^size_t Multigrid::getBoundaryList_level_joined_start(size_t level) {$/;"	f	class:Multigrid
getBoundaryRight	boundary/Boundary.h	/^    size_t* getBoundaryRight() { return m_boundaryRight;}$/;"	f	class:Boundary
getBoundaryTop	boundary/Boundary.h	/^    size_t* getBoundaryTop() {return m_boundaryTop;}$/;"	f	class:Boundary
getCoordinateI	utility/GlobalMacrosTypes.h	71;"	d
getCoordinateJ	utility/GlobalMacrosTypes.h	72;"	d
getCoordinateK	utility/GlobalMacrosTypes.h	73;"	d
getCoordinates_i1	boundary/Obstacle.h	/^    size_t getCoordinates_i1() { return m_i1; }$/;"	f	class:Obstacle
getCoordinates_i2	boundary/Obstacle.h	/^    size_t getCoordinates_i2() { return m_i2; }$/;"	f	class:Obstacle
getCoordinates_j1	boundary/Obstacle.h	/^    size_t getCoordinates_j1() { return m_j1; }$/;"	f	class:Obstacle
getCoordinates_j2	boundary/Obstacle.h	/^    size_t getCoordinates_j2() { return m_j2; }$/;"	f	class:Obstacle
getCoordinates_k1	boundary/Obstacle.h	/^    size_t getCoordinates_k1() { return m_k1; }$/;"	f	class:Obstacle
getCoordinates_k2	boundary/Obstacle.h	/^    size_t getCoordinates_k2() { return m_k2; }$/;"	f	class:Obstacle
getExpansionSize	adaption/Layers.cpp	/^size_t Layers::getExpansionSize() {$/;"	f	class:Layers
getFieldTypeName	boundary/BoundaryData.cpp	/^std::string BoundaryData::getFieldTypeName(FieldType f) {$/;"	f	class:BoundaryData
getFirstIndex_bList	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_bList(size_t level) {$/;"	f	class:Multigrid
getFirstIndex_bSliceX	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_bSliceX(size_t level) {$/;"	f	class:Multigrid
getFirstIndex_bSliceY	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_bSliceY(size_t level) {$/;"	f	class:Multigrid
getFirstIndex_bSliceZ	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_bSliceZ(size_t level) {$/;"	f	class:Multigrid
getFirstIndex_iList	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_iList(size_t level) {$/;"	f	class:Multigrid
getFirstIndex_oBack	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_oBack(size_t level, size_t id) {$/;"	f	class:Multigrid
getFirstIndex_oBottom	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_oBottom(size_t level, size_t id) {$/;"	f	class:Multigrid
getFirstIndex_oFront	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_oFront(size_t level, size_t id) {$/;"	f	class:Multigrid
getFirstIndex_oLeft	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_oLeft(size_t level, size_t id) {$/;"	f	class:Multigrid
getFirstIndex_oRight	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_oRight(size_t level, size_t id) {$/;"	f	class:Multigrid
getFirstIndex_oTop	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_oTop(size_t level, size_t id) {$/;"	f	class:Multigrid
getFirstIndex_sList	boundary/Multigrid.cpp	/^size_t Multigrid::getFirstIndex_sList(size_t level) {$/;"	f	class:Multigrid
getInnerList	boundary/Boundary.h	/^    size_t* getInnerList() { return m_innerList;}$/;"	f	class:Boundary
getInnerList_level_joined	boundary/Multigrid.h	/^    size_t* getInnerList_level_joined() { return m_data_MG_iList_level_joined; };$/;"	f	class:Multigrid
getInnerList_level_joined_end	boundary/Multigrid.cpp	/^size_t Multigrid::getInnerList_level_joined_end(size_t level) {$/;"	f	class:Multigrid
getInnerList_level_joined_start	boundary/Multigrid.cpp	/^size_t Multigrid::getInnerList_level_joined_start(size_t level) {$/;"	f	class:Multigrid
getInstance	Domain.cpp	/^Domain *Domain::getInstance() {$/;"	f	class:Domain
getInstance	boundary/BoundaryController.cpp	/^BoundaryController *BoundaryController::getInstance() {$/;"	f	class:BoundaryController
getInstance	utility/Parameters.cpp	/^Parameters *Parameters::getInstance() {$/;"	f	class:Parameters
getLastIndex_bList	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_bList(size_t level) {$/;"	f	class:Multigrid
getLastIndex_bSliceX	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_bSliceX(size_t level) {$/;"	f	class:Multigrid
getLastIndex_bSliceY	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_bSliceY(size_t level) {$/;"	f	class:Multigrid
getLastIndex_bSliceZ	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_bSliceZ(size_t level) {$/;"	f	class:Multigrid
getLastIndex_iList	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_iList(size_t level) {$/;"	f	class:Multigrid
getLastIndex_oBack	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_oBack(size_t level, size_t id) {$/;"	f	class:Multigrid
getLastIndex_oBottom	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_oBottom(size_t level, size_t id) {$/;"	f	class:Multigrid
getLastIndex_oFront	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_oFront(size_t level, size_t id) {$/;"	f	class:Multigrid
getLastIndex_oLeft	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_oLeft(size_t level, size_t id) {$/;"	f	class:Multigrid
getLastIndex_oRight	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_oRight(size_t level, size_t id) {$/;"	f	class:Multigrid
getLastIndex_oTop	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_oTop(size_t level, size_t id) {$/;"	f	class:Multigrid
getLastIndex_sList	boundary/Multigrid.cpp	/^size_t Multigrid::getLastIndex_sList(size_t level) {$/;"	f	class:Multigrid
getLen_bList_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_bList_joined() {$/;"	f	class:Multigrid
getLen_bSliceX_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_bSliceX_joined() {$/;"	f	class:Multigrid
getLen_bSliceY_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_bSliceY_joined() {$/;"	f	class:Multigrid
getLen_bSliceZ_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_bSliceZ_joined() {$/;"	f	class:Multigrid
getLen_iList_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_iList_joined() {$/;"	f	class:Multigrid
getLen_oBack	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oBack(size_t level) {$/;"	f	class:Multigrid
getLen_oBack_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oBack_joined() {$/;"	f	class:Multigrid
getLen_oBottom	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oBottom(size_t level) {$/;"	f	class:Multigrid
getLen_oBottom_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oBottom_joined() {$/;"	f	class:Multigrid
getLen_oFront	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oFront(size_t level) {$/;"	f	class:Multigrid
getLen_oFront_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oFront_joined() {$/;"	f	class:Multigrid
getLen_oLeft	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oLeft(size_t level) {$/;"	f	class:Multigrid
getLen_oLeft_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oLeft_joined() {$/;"	f	class:Multigrid
getLen_oRight	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oRight(size_t level) {$/;"	f	class:Multigrid
getLen_oRight_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oRight_joined() {$/;"	f	class:Multigrid
getLen_oTop	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oTop(size_t level) {$/;"	f	class:Multigrid
getLen_oTop_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_oTop_joined() {$/;"	f	class:Multigrid
getLen_sList_joined	boundary/Multigrid.cpp	/^size_t Multigrid::getLen_sList_joined() {$/;"	f	class:Multigrid
getObstacleBack	boundary/Obstacle.h	/^    size_t* getObstacleBack() { return m_obstacleBack; }$/;"	f	class:Obstacle
getObstacleBottom	boundary/Obstacle.h	/^    size_t* getObstacleBottom() { return m_obstacleBottom; }$/;"	f	class:Obstacle
getObstacleFront	boundary/Obstacle.h	/^    size_t* getObstacleFront() { return m_obstacleFront; }$/;"	f	class:Obstacle
getObstacleLeft	boundary/Obstacle.h	/^    size_t* getObstacleLeft() { return m_obstacleLeft; }$/;"	f	class:Obstacle
getObstacleList	boundary/Obstacle.h	/^    size_t* getObstacleList() { return m_obstacleList; }$/;"	f	class:Obstacle
getObstacleRight	boundary/Obstacle.h	/^    size_t* getObstacleRight() { return m_obstacleRight; }$/;"	f	class:Obstacle
getObstacleStrideX	boundary/BoundaryController.cpp	/^size_t BoundaryController::getObstacleStrideX(size_t id, size_t level){$/;"	f	class:BoundaryController
getObstacleStrideX	boundary/Multigrid.cpp	/^size_t Multigrid::getObstacleStrideX(size_t id, size_t level) {$/;"	f	class:Multigrid
getObstacleStrideY	boundary/BoundaryController.cpp	/^size_t BoundaryController::getObstacleStrideY(size_t id, size_t level){$/;"	f	class:BoundaryController
getObstacleStrideY	boundary/Multigrid.cpp	/^size_t Multigrid::getObstacleStrideY(size_t id, size_t level) {$/;"	f	class:Multigrid
getObstacleStrideZ	boundary/BoundaryController.cpp	/^size_t BoundaryController::getObstacleStrideZ(size_t id, size_t level){$/;"	f	class:BoundaryController
getObstacleStrideZ	boundary/Multigrid.cpp	/^size_t Multigrid::getObstacleStrideZ(size_t id, size_t level) {$/;"	f	class:Multigrid
getObstacleTop	boundary/Obstacle.h	/^    size_t* getObstacleTop() { return m_obstacleTop; }$/;"	f	class:Obstacle
getPatchName	boundary/BoundaryData.cpp	/^std::string BoundaryData::getPatchName(Patch p) {$/;"	f	class:BoundaryData
getSize_boundaryBack	boundary/Boundary.h	/^    size_t getSize_boundaryBack() {return   m_size_boundaryBack;}$/;"	f	class:Boundary
getSize_boundaryBottom	boundary/Boundary.h	/^    size_t getSize_boundaryBottom() {return m_size_boundaryBottom;}$/;"	f	class:Boundary
getSize_boundaryFront	boundary/Boundary.h	/^    size_t getSize_boundaryFront() {return  m_size_boundaryFront;}$/;"	f	class:Boundary
getSize_boundaryLeft	boundary/Boundary.h	/^    size_t getSize_boundaryLeft() {return   m_size_boundaryLeft;}$/;"	f	class:Boundary
getSize_boundaryList	boundary/Boundary.h	/^    size_t getSize_boundaryList() {return m_size_boundaryList;}$/;"	f	class:Boundary
getSize_boundaryList	boundary/BoundaryController.cpp	/^size_t BoundaryController::getSize_boundaryList() {$/;"	f	class:BoundaryController
getSize_boundaryList	boundary/Multigrid.cpp	/^size_t Multigrid::getSize_boundaryList(size_t level) {$/;"	f	class:Multigrid
getSize_boundaryList_level_joined	boundary/BoundaryController.cpp	/^size_t BoundaryController::getSize_boundaryList_level_joined() {$/;"	f	class:BoundaryController
getSize_boundaryList_level_joined	boundary/Multigrid.h	/^    size_t getSize_boundaryList_level_joined() { return *(m_size_MG_bList_level + m_levels + 1); };$/;"	f	class:Multigrid
getSize_boundaryRight	boundary/Boundary.h	/^    size_t getSize_boundaryRight() { return m_size_boundaryRight;}$/;"	f	class:Boundary
getSize_boundaryTop	boundary/Boundary.h	/^    size_t getSize_boundaryTop() {return    m_size_boundaryTop;}$/;"	f	class:Boundary
getSize_innerList	boundary/Boundary.h	/^    size_t getSize_innerList() { return m_size_innerList; }$/;"	f	class:Boundary
getSize_innerList	boundary/BoundaryController.cpp	/^size_t BoundaryController::getSize_innerList() {$/;"	f	class:BoundaryController
getSize_innerList	boundary/Multigrid.cpp	/^size_t Multigrid::getSize_innerList(size_t level) {$/;"	f	class:Multigrid
getSize_innerList_level_joined	boundary/BoundaryController.cpp	/^size_t BoundaryController::getSize_innerList_level_joined() {$/;"	f	class:BoundaryController
getSize_innerList_level_joined	boundary/Multigrid.h	/^    size_t getSize_innerList_level_joined() { return *(m_size_MG_iList_level + m_levels + 1); };$/;"	f	class:Multigrid
getSize_oList	boundary/Multigrid.cpp	/^size_t Multigrid::getSize_oList(size_t level) {$/;"	f	class:Multigrid
getSize_obstacleBack	boundary/Obstacle.h	/^    size_t getSize_obstacleBack() { return m_size_obstacleBack; }$/;"	f	class:Obstacle
getSize_obstacleBottom	boundary/Obstacle.h	/^    size_t getSize_obstacleBottom() { return m_size_obstacleBottom; }$/;"	f	class:Obstacle
getSize_obstacleFront	boundary/Obstacle.h	/^    size_t getSize_obstacleFront() { return m_size_obstacleFront; }$/;"	f	class:Obstacle
getSize_obstacleLeft	boundary/Obstacle.h	/^    size_t getSize_obstacleLeft() { return m_size_obstacleLeft; }$/;"	f	class:Obstacle
getSize_obstacleList	boundary/BoundaryController.cpp	/^size_t BoundaryController::getSize_obstacleList() {$/;"	f	class:BoundaryController
getSize_obstacleList	boundary/Multigrid.cpp	/^size_t Multigrid::getSize_obstacleList() {$/;"	f	class:Multigrid
getSize_obstacleList	boundary/Obstacle.h	/^    size_t getSize_obstacleList() { return m_size_obstacleList; }$/;"	f	class:Obstacle
getSize_obstacleRight	boundary/Obstacle.h	/^    size_t getSize_obstacleRight() { return m_size_obstacleRight; }$/;"	f	class:Obstacle
getSize_obstacleTop	boundary/Obstacle.h	/^    size_t getSize_obstacleTop() { return m_size_obstacleTop; }$/;"	f	class:Obstacle
getSize_surfaceList	boundary/BoundaryController.h	/^    size_t getSize_surfaceList() {return m_size_sList;};$/;"	f	class:BoundaryController
getSize_surfaceList	boundary/Surface.h	/^    size_t getSize_surfaceList() {return m_size_surfaceList;}$/;"	f	class:Surface
getStrideX	boundary/Obstacle.h	/^    size_t getStrideX() { return m_i2 - m_i1 + 1; }$/;"	f	class:Obstacle
getStrideX	boundary/Surface.h	/^    size_t getStrideX() { return m_strideX;}$/;"	f	class:Surface
getStrideY	boundary/Obstacle.h	/^    size_t getStrideY() { return m_j2 - m_j1 + 1; }$/;"	f	class:Obstacle
getStrideY	boundary/Surface.h	/^    size_t getStrideY() { return m_strideY;}$/;"	f	class:Surface
getStrideZ	boundary/Obstacle.h	/^    size_t getStrideZ() { return m_k2 - m_k1 + 1; }$/;"	f	class:Obstacle
getStrideZ	boundary/Surface.h	/^    size_t getStrideZ() { return m_strideZ;}$/;"	f	class:Surface
getSurfaceID	boundary/Surface.h	/^    size_t getSurfaceID() { return m_surfaceID;}$/;"	f	class:Surface
getSurfaceList	boundary/Surface.h	/^    size_t* getSurfaceList() {return m_surfaceList;}$/;"	f	class:Surface
getValue	boundary/BoundaryData.h	/^    real getValue(Patch p){ return m_values[p];};$/;"	f	class:BoundaryData
get_Lx	Domain.h	/^    real inline get_Lx() const { return fabs(m_X2 - m_X1); }$/;"	f	class:Domain
get_Ly	Domain.h	/^    real inline get_Ly() const { return fabs(m_Y2 - m_Y1); }$/;"	f	class:Domain
get_Lz	Domain.h	/^    real inline get_Lz() const { return fabs(m_Z2 - m_Z1); }$/;"	f	class:Domain
get_Nx	Domain.h	/^    size_t inline get_Nx() const { return static_cast<size_t> (std::round(get_Lx() \/ get_dx() + 2)); }$/;"	f	class:Domain
get_Nx	Domain.h	/^    size_t inline get_Nx(size_t level) const { return static_cast<size_t> (std::round(get_Lx() \/ get_dx(level) + 2)); }$/;"	f	class:Domain
get_Ny	Domain.h	/^    size_t inline get_Ny() const { return static_cast<size_t> (std::round(get_Ly() \/ get_dy() + 2)); }$/;"	f	class:Domain
get_Ny	Domain.h	/^    size_t inline get_Ny(size_t level) const { return static_cast<size_t> (std::round(get_Ly() \/ get_dy(level) + 2)); }$/;"	f	class:Domain
get_Nz	Domain.h	/^    size_t inline get_Nz() const { return static_cast<size_t> (std::round(get_Lz() \/ get_dz() + 2)); }$/;"	f	class:Domain
get_Nz	Domain.h	/^    size_t inline get_Nz(size_t level) const { return static_cast<size_t> (std::round(get_Lz() \/ get_dz(level) + 2)); }$/;"	f	class:Domain
get_X1	Domain.h	/^    real inline get_X1() const { return this->m_X1; }$/;"	f	class:Domain
get_X2	Domain.h	/^    real inline get_X2() const { return this->m_X2; }$/;"	f	class:Domain
get_Y1	Domain.h	/^    real inline get_Y1() const { return this->m_Y1; }$/;"	f	class:Domain
get_Y2	Domain.h	/^    real inline get_Y2() const { return this->m_Y2; }$/;"	f	class:Domain
get_Z1	Domain.h	/^    real inline get_Z1() const { return this->m_Z1; }$/;"	f	class:Domain
get_Z2	Domain.h	/^    real inline get_Z2() const { return this->m_Z2; }$/;"	f	class:Domain
get_after_height	adaption/Adaption.h	/^    real inline get_after_height() { return m_height_after; }$/;"	f	class:ADTypes::Adaption
get_after_name	adaption/Adaption.h	/^    std::string inline get_after_name() { return m_filename + "_after.csv"; }$/;"	f	class:ADTypes::Adaption::std
get_before_height	adaption/Adaption.h	/^    real inline get_before_height() { return m_height_before; }$/;"	f	class:ADTypes::Adaption
get_before_name	adaption/Adaption.h	/^    std::string inline get_before_name() { return m_filename + "_before.csv"; }$/;"	f	class:ADTypes::Adaption::std
get_boundaryList_level_joined	boundary/BoundaryController.cpp	/^size_t *BoundaryController::get_boundaryList_level_joined() {$/;"	f	class:BoundaryController
get_boundaryList_level_joined_end	boundary/BoundaryController.cpp	/^size_t BoundaryController::get_boundaryList_level_joined_end(size_t level) {$/;"	f	class:BoundaryController
get_boundaryList_level_joined_start	boundary/BoundaryController.cpp	/^size_t BoundaryController::get_boundaryList_level_joined_start(size_t level) {$/;"	f	class:BoundaryController
get_data	field/Field.h	/^    return_ptr get_data() const { return data; }$/;"	f	class:Field
get_double	utility/Parameters.cpp	/^double Parameters::get_double(const std::string &raw_path) {$/;"	f	class:Parameters
get_dx	Domain.h	/^    real inline get_dx() const { return this->get_lx() \/ (static_cast<double>(m_nx[0]) - 2); }$/;"	f	class:Domain
get_dx	Domain.h	/^    real inline get_dx(size_t level) const { return this->get_lx() \/ (static_cast<double>(m_nx[level]) - 2); }$/;"	f	class:Domain
get_dy	Domain.h	/^    real inline get_dy() const { return this->get_ly() \/ (static_cast<double>(m_ny[0]) - 2); }$/;"	f	class:Domain
get_dy	Domain.h	/^    real inline get_dy(size_t level) const { return this->get_ly() \/ (static_cast<double>(m_ny[level]) - 2); }$/;"	f	class:Domain
get_dz	Domain.h	/^    real inline get_dz() const { return this->get_lz() \/ (static_cast<double>(m_nz[0]) - 2); }$/;"	f	class:Domain
get_dz	Domain.h	/^    real inline get_dz(size_t level) const { return this->get_lz() \/ (static_cast<double>(m_nz[level]) - 2); }$/;"	f	class:Domain
get_endresult_name	adaption/Adaption.h	/^    std::string inline get_endresult_name() { return m_filename + "_endresult.csv"; }$/;"	f	class:ADTypes::Adaption::std
get_field_T0_data	field/FieldController.h	/^    real* get_field_T0_data() const { return field_T0->data; }$/;"	f	class:FieldController
get_field_T_data	field/FieldController.h	/^    real* get_field_T_data() const { return field_T->data; }$/;"	f	class:FieldController
get_field_T_tmp_data	field/FieldController.h	/^    real* get_field_T_tmp_data() const { return field_T_tmp->data; }$/;"	f	class:FieldController
get_field_concentration0_data	field/FieldController.h	/^    real* get_field_concentration0_data() const { return field_concentration0->data; }$/;"	f	class:FieldController
get_field_concentration_data	field/FieldController.h	/^    real* get_field_concentration_data() const { return field_concentration->data; }$/;"	f	class:FieldController
get_field_concentration_tmp_data	field/FieldController.h	/^    real* get_field_concentration_tmp_data() const { return field_concentration_tmp->data; }$/;"	f	class:FieldController
get_field_controller	solver/SolverController.h	/^    FieldController* get_field_controller() { return m_field_controller; };$/;"	f	class:SolverController
get_field_nu_t_data	field/FieldController.h	/^    real* get_field_nu_t_data() const { return field_nu_t->data; }$/;"	f	class:FieldController
get_field_p0_data	field/FieldController.h	/^    real* get_field_p0_data() const { return field_p0->data; }$/;"	f	class:FieldController
get_field_p_data	field/FieldController.h	/^    real* get_field_p_data() const { return field_p->data; }$/;"	f	class:FieldController
get_field_rhs_data	field/FieldController.h	/^    real* get_field_rhs_data() const { return field_rhs->data; }$/;"	f	class:FieldController
get_field_sight_data	field/FieldController.h	/^    real* get_field_sight_data() const { return sight->data; }$/;"	f	class:FieldController
get_field_source_T_data	field/FieldController.h	/^    real* get_field_source_T_data() const { return field_source_T->data; }$/;"	f	class:FieldController
get_field_u0_data	field/FieldController.h	/^    real* get_field_u0_data() const { return field_u0->data; }$/;"	f	class:FieldController
get_field_u_data	field/FieldController.h	/^    real* get_field_u_data() const { return field_u->data; }$/;"	f	class:FieldController
get_field_u_tmp_data	field/FieldController.h	/^    real* get_field_u_tmp_data() const { return field_u_tmp->data; }$/;"	f	class:FieldController
get_field_v0_data	field/FieldController.h	/^    real* get_field_v0_data() const { return field_v0->data; }$/;"	f	class:FieldController
get_field_v_data	field/FieldController.h	/^    real* get_field_v_data() const { return field_v->data; }$/;"	f	class:FieldController
get_field_v_tmp_data	field/FieldController.h	/^    real* get_field_v_tmp_data() const { return field_v_tmp->data; }$/;"	f	class:FieldController
get_field_w0_data	field/FieldController.h	/^    real* get_field_w0_data() const { return field_w0->data; }$/;"	f	class:FieldController
get_field_w_data	field/FieldController.h	/^    real* get_field_w_data() const { return field_w->data; }$/;"	f	class:FieldController
get_field_w_tmp_data	field/FieldController.h	/^    real* get_field_w_tmp_data() const { return field_w_tmp->data; }$/;"	f	class:FieldController
get_filename	utility/Parameters.h	/^    std::string get_filename() {return m_filename; }$/;"	f	class:Parameters
get_first_child	utility/Parameters.cpp	/^tinyxml2::XMLElement* Parameters::get_first_child(const char* raw_path){$/;"	f	class:Parameters
get_i2	boundary/Surface.cpp	/^size_t Surface::get_i2() {$/;"	f	class:Surface
get_index	utility/Utility.cpp	/^size_t get_index(real physical_coordinate, real spacing, real start_coordinate) {$/;"	f	namespace:Utility
get_index_x1	Domain.h	/^    size_t inline get_index_x1() const { return get_index_x1(0); }$/;"	f	class:Domain
get_index_x1	Domain.h	/^    size_t inline get_index_x1(size_t level) const { return static_cast<size_t> (std::round((m_x1 - m_X1) \/ get_dx(level))) + 1; }$/;"	f	class:Domain
get_index_x2	Domain.h	/^    size_t inline get_index_x2() const { return get_index_x2(0); }$/;"	f	class:Domain
get_index_x2	Domain.h	/^    size_t inline get_index_x2(size_t level) const { return static_cast<size_t> (std::round((m_x2 - m_X1) \/ get_dx(level))); }$/;"	f	class:Domain
get_index_y1	Domain.h	/^    size_t inline get_index_y1() const { return get_index_y1(0); }$/;"	f	class:Domain
get_index_y1	Domain.h	/^    size_t inline get_index_y1(size_t level) const { return static_cast<size_t> (std::round((m_y1 - m_Y1) \/ get_dy(level))) + 1; }$/;"	f	class:Domain
get_index_y2	Domain.h	/^    size_t inline get_index_y2() const { return get_index_y2(0); }$/;"	f	class:Domain
get_index_y2	Domain.h	/^    size_t inline get_index_y2(size_t level) const { return static_cast<size_t> (std::round((m_y2 - m_Y1) \/ get_dy(level))); }$/;"	f	class:Domain
get_index_z1	Domain.h	/^    size_t inline get_index_z1() const { return get_index_z1(0); }$/;"	f	class:Domain
get_index_z1	Domain.h	/^    size_t inline get_index_z1(size_t level) const { return static_cast<size_t> (std::round((m_z1 - m_Z1) \/ get_dz(level))) + 1; }$/;"	f	class:Domain
get_index_z2	Domain.h	/^    size_t inline get_index_z2() const { return get_index_z2(0); }$/;"	f	class:Domain
get_index_z2	Domain.h	/^    size_t inline get_index_z2(size_t level) const { return static_cast<size_t> (std::round((m_z2 - m_Z1) \/ get_dz(level))); }$/;"	f	class:Domain
get_innerList_level_joined	boundary/BoundaryController.cpp	/^size_t *BoundaryController::get_innerList_level_joined() {$/;"	f	class:BoundaryController
get_innerList_level_joined_end	boundary/BoundaryController.cpp	/^size_t BoundaryController::get_innerList_level_joined_end(size_t level) {$/;"	f	class:BoundaryController
get_innerList_level_joined_start	boundary/BoundaryController.cpp	/^size_t BoundaryController::get_innerList_level_joined_start(size_t level) {$/;"	f	class:BoundaryController
get_int	utility/Parameters.cpp	/^int Parameters::get_int(const std::string &raw_path) {$/;"	f	class:Parameters
get_j2	boundary/Surface.cpp	/^size_t Surface::get_j2() {$/;"	f	class:Surface
get_k2	boundary/Surface.cpp	/^size_t Surface::get_k2() {$/;"	f	class:Surface
get_level	field/Field.h	/^    size_t get_level() const { return m_level; }$/;"	f	class:Field
get_levels	Domain.h	/^    size_t inline get_levels() const { return m_levels; }$/;"	f	class:Domain
get_lx	Domain.h	/^    real inline get_lx() const { return fabs(m_x2 - m_x1); }$/;"	f	class:Domain
get_ly	Domain.h	/^    real inline get_ly() const { return fabs(m_y2 - m_y1); }$/;"	f	class:Domain
get_lz	Domain.h	/^    real inline get_lz() const { return fabs(m_z2 - m_z1); }$/;"	f	class:Domain
get_nx	Domain.h	/^    size_t inline get_nx() const { return this->m_nx[0]; }$/;"	f	class:Domain
get_nx	Domain.h	/^    size_t inline get_nx(size_t level) const { return this->m_nx[level]; }$/;"	f	class:Domain
get_ny	Domain.h	/^    size_t inline get_ny() const { return this->m_ny[0]; }$/;"	f	class:Domain
get_ny	Domain.h	/^    size_t inline get_ny(size_t level) const { return this->m_ny[level]; }$/;"	f	class:Domain
get_nz	Domain.h	/^    size_t inline get_nz() const { return this->m_nz[0]; }$/;"	f	class:Domain
get_nz	Domain.h	/^    size_t inline get_nz(size_t level) const { return this->m_nz[level]; }$/;"	f	class:Domain
get_obstacleList	boundary/BoundaryController.cpp	/^size_t* BoundaryController::get_obstacleList() {$/;"	f	class:BoundaryController
get_obstacleList	boundary/Multigrid.cpp	/^size_t* Multigrid::get_obstacleList(){$/;"	f	class:Multigrid
get_real	utility/Parameters.cpp	/^real Parameters::get_real(const std::string &raw_path) {$/;"	f	class:Parameters
get_size	Domain.h	/^    size_t inline get_size() const { return get_Nx() * get_Ny() * get_Nz(); }$/;"	f	class:Domain
get_size	Domain.h	/^    size_t inline get_size(size_t level) const { return get_Nx(level) * get_Ny(level) * get_Nz(level); }$/;"	f	class:Domain
get_size	field/Field.h	/^    size_t get_size() const { return m_size; }$/;"	f	class:Field
get_time_measuring_name	adaption/Adaption.h	/^    std::string inline get_time_measuring_name() { return m_filename + "_time.csv"; }$/;"	f	class:ADTypes::Adaption::std
get_time_value	source/GaussFunction.cpp	/^real GaussFunction::get_time_value(real t_cur) {$/;"	f	class:GaussFunction
get_type	field/Field.h	/^    FieldType get_type() const { return m_type; }$/;"	f	class:Field
get_used_fields	boundary/BoundaryController.cpp	/^std::vector<FieldType> BoundaryController::get_used_fields() {$/;"	f	class:BoundaryController
get_used_fields	boundary/BoundaryDataController.cpp	/^std::vector<FieldType> BoundaryDataController::get_used_fields() {$/;"	f	class:BoundaryDataController
get_write_runtime_name	adaption/Adaption.h	/^    std::string inline get_write_runtime_name() { return m_filename + "_runtime.csv"; }$/;"	f	class:ADTypes::Adaption::std
get_x1	Domain.h	/^    real inline get_x1() const { return this->m_x1; }$/;"	f	class:Domain
get_x2	Domain.h	/^    real inline get_x2() const { return this->m_x2; }$/;"	f	class:Domain
get_y1	Domain.h	/^    real inline get_y1() const { return this->m_y1; }$/;"	f	class:Domain
get_y2	Domain.h	/^    real inline get_y2() const { return this->m_y2; }$/;"	f	class:Domain
get_z1	Domain.h	/^    real inline get_z1() const { return this->m_z1; }$/;"	f	class:Domain
get_z2	Domain.h	/^    real inline get_z2() const { return this->m_z2; }$/;"	f	class:Domain
has_analytic_solution	analysis/Analysis.h	/^    bool has_analytic_solution = false;$/;"	m	class:Analysis
has_reduction	adaption/Vortex.cpp	/^bool Vortex::has_reduction() {$/;"	f	class:Vortex
hat	analysis/Solution.cpp	/^void Solution::hat(const real t) {$/;"	f	class:Solution
init	analysis/Solution.cpp	/^void Solution::init(std::string initial_condition) {$/;"	f	class:Solution
init	boundary/Boundary.cpp	/^void Boundary::init(size_t size_obstacles){$/;"	f	class:Boundary
init	boundary/Multigrid.cpp	/^void Multigrid::init() {$/;"	f	class:Multigrid
init	boundary/Obstacle.cpp	/^void Obstacle::init(size_t level) {$/;"	f	class:Obstacle
init	boundary/Surface.cpp	/^void Surface::init(size_t Nx, size_t Ny) {$/;"	f	class:Surface
init_solver	solver/SolverController.cpp	/^void SolverController::init_solver(const std::string &string_solver) {$/;"	f	class:SolverController
initialise_grid	visualisation/Visual.cpp	/^void Visual::initialise_grid(float *x_coords, float *y_coords, float *z_coords, int Nx, int Ny, int Nz, real dx, real dy, real dz) {$/;"	f	class:Visual
innerCells	boundary/Boundary.cpp	/^void Boundary::innerCells() {$/;"	f	class:Boundary
innerCells	boundary/Boundary.cpp	/^void Boundary::innerCells(Obstacle **obstacleList, size_t numberOfObstacles) {$/;"	f	class:Boundary
isEmpty	boundary/BoundaryData.h	/^    bool isEmpty(){ return !m_hasValues; };$/;"	f	class:BoundaryData
isObstacleCell	boundary/Obstacle.cpp	/^bool Obstacle::isObstacleCell(size_t i, size_t j, size_t k) {$/;"	f	class:Obstacle
isUpdateNecessary	adaption/Adaption.cpp	/^bool Adaption::isUpdateNecessary() {$/;"	f	class:Adaption
is_data_extraction_after_enabled	adaption/Adaption.h	/^    bool inline is_data_extraction_after_enabled() { return m_has_data_extraction_after; }$/;"	f	class:ADTypes::Adaption
is_data_extraction_before_enabled	adaption/Adaption.h	/^    bool inline is_data_extraction_before_enabled() { return m_has_data_extraction_before; }$/;"	f	class:ADTypes::Adaption
is_data_extraction_enabled	adaption/Adaption.h	/^    bool inline is_data_extraction_enabled() { return m_has_data_extraction; };$/;"	f	class:ADTypes::Adaption
is_data_extraction_endresult_enabled	adaption/Adaption.h	/^    bool inline is_data_extraction_endresult_enabled() { return m_has_data_extraction_endresult; }$/;"	f	class:ADTypes::Adaption
is_time_measuring_enabled	adaption/Adaption.h	/^    bool inline is_time_measuring_enabled() { return m_has_time_measuring; }$/;"	f	class:ADTypes::Adaption
is_write_runtime_enabled	adaption/Adaption.h	/^    bool inline is_write_runtime_enabled() { return m_has_write_runtime; }$/;"	f	class:ADTypes::Adaption
length	utility/tinyxml2.cpp	/^    int length;$/;"	m	struct:tinyxml2::Entity	file:
levels	pressure/VCycleMG.h	/^    int levels;$/;"	m	class:VCycleMG
m_Cs	turbulence/ConstSmagorinsky.h	/^    real m_Cs;$/;"	m	class:ConstSmagorinsky
m_MG_boundaryList	boundary/Multigrid.h	/^    Boundary** m_MG_boundaryList; \/\/m_MG_boundaryList[level]$/;"	m	class:Multigrid
m_MG_oBack	boundary/Multigrid.h	/^    size_t** m_MG_oBack;$/;"	m	class:Multigrid
m_MG_oBottom	boundary/Multigrid.h	/^    size_t** m_MG_oBottom;$/;"	m	class:Multigrid
m_MG_oFront	boundary/Multigrid.h	/^    size_t** m_MG_oFront;$/;"	m	class:Multigrid
m_MG_oLeft	boundary/Multigrid.h	/^    size_t** m_MG_oLeft;$/;"	m	class:Multigrid
m_MG_oList	boundary/Multigrid.h	/^    size_t** m_MG_oList;$/;"	m	class:Multigrid
m_MG_oRight	boundary/Multigrid.h	/^    size_t** m_MG_oRight;$/;"	m	class:Multigrid
m_MG_oTop	boundary/Multigrid.h	/^    size_t** m_MG_oTop;$/;"	m	class:Multigrid
m_MG_obstacleList	boundary/Multigrid.h	/^    Obstacle*** m_MG_obstacleList; \/\/m_MG_obstacleList[level][obstacleID]$/;"	m	class:Multigrid
m_MG_sList	boundary/Multigrid.h	/^    size_t** m_MG_sList;$/;"	m	class:Multigrid
m_MG_surfaceList	boundary/Multigrid.h	/^    Surface*** m_MG_surfaceList; \/\/m_MG_surfaceList[level][surfaceID]$/;"	m	class:Multigrid
m_Nu	adaption/Layers.h	/^    Field *m_T, *m_Ta, *m_Nu, *m_kappa, *m_gamma;$/;"	m	class:Layers
m_T	adaption/Layers.h	/^    Field *m_T, *m_Ta, *m_Nu, *m_kappa, *m_gamma;$/;"	m	class:Layers
m_Ta	adaption/Layers.h	/^    Field *m_T, *m_Ta, *m_Nu, *m_kappa, *m_gamma;$/;"	m	class:Layers
m_X1	Domain.h	/^    real m_X1, m_X2, m_Y1, m_Y2, m_Z1, m_Z2;$/;"	m	class:Domain
m_X2	Domain.h	/^    real m_X1, m_X2, m_Y1, m_Y2, m_Z1, m_Z2;$/;"	m	class:Domain
m_Y1	Domain.h	/^    real m_X1, m_X2, m_Y1, m_Y2, m_Z1, m_Z2;$/;"	m	class:Domain
m_Y2	Domain.h	/^    real m_X1, m_X2, m_Y1, m_Y2, m_Z1, m_Z2;$/;"	m	class:Domain
m_Z1	Domain.h	/^    real m_X1, m_X2, m_Y1, m_Y2, m_Z1, m_Z2;$/;"	m	class:Domain
m_Z2	Domain.h	/^    real m_X1, m_X2, m_Y1, m_Y2, m_Z1, m_Z2;$/;"	m	class:Domain
m_adaption	TimeIntegration.h	/^    Adaption *m_adaption;$/;"	m	class:TimeIntegration
m_analysis	TimeIntegration.h	/^    Analysis *m_analysis;$/;"	m	class:TimeIntegration
m_bdc_boundary	boundary/BoundaryController.h	/^    BoundaryDataController *m_bdc_boundary;$/;"	m	class:BoundaryController
m_bdc_boundary	boundary/Multigrid.h	/^    BoundaryDataController* m_bdc_boundary;$/;"	m	class:Multigrid
m_bdc_obstacle	boundary/Multigrid.h	/^    BoundaryDataController** m_bdc_obstacle;$/;"	m	class:Multigrid
m_bdc_obstacles	boundary/BoundaryController.h	/^    BoundaryDataController **m_bdc_obstacles;$/;"	m	class:BoundaryController
m_boundaryBack	boundary/Boundary.h	/^    size_t* m_boundaryBack;$/;"	m	class:Boundary
m_boundaryBottom	boundary/Boundary.h	/^    size_t* m_boundaryBottom;$/;"	m	class:Boundary
m_boundaryConditions	boundary/BoundaryData.h	/^    BoundaryCondition* m_boundaryConditions;$/;"	m	class:BoundaryData
m_boundaryData	boundary/BoundaryDataController.h	/^    BoundaryData** m_boundaryData;$/;"	m	class:BoundaryDataController
m_boundaryDataController	boundary/Surface.h	/^    BoundaryDataController* m_boundaryDataController;$/;"	m	class:Surface
m_boundaryFront	boundary/Boundary.h	/^    size_t* m_boundaryFront;$/;"	m	class:Boundary
m_boundaryLeft	boundary/Boundary.h	/^    size_t* m_boundaryLeft;$/;"	m	class:Boundary
m_boundaryList	boundary/Boundary.h	/^    size_t* m_boundaryList;$/;"	m	class:Boundary
m_boundaryRight	boundary/Boundary.h	/^    size_t* m_boundaryRight;$/;"	m	class:Boundary
m_boundaryTop	boundary/Boundary.h	/^    size_t* m_boundaryTop;$/;"	m	class:Boundary
m_buffer	adaption/Vortex.h	/^    size_t m_buffer;$/;"	m	class:Vortex
m_check_value	adaption/Layers.h	/^    real m_check_value;$/;"	m	class:Layers
m_conFct	solver/NSTempConSolver.h	/^    std::string m_conFct;$/;"	m	class:NSTempConSolver
m_conFct	solver/NSTempTurbConSolver.h	/^    std::string m_conFct;$/;"	m	class:NSTempTurbConSolver
m_csv_plots	visualisation/Visual.h	/^    int m_csv_plots = 0;$/;"	m	class:Visual
m_current_time_step	analysis/Solution.h	/^    real m_current_time_step = -1;$/;"	m	class:Solution
m_data_MG_bBack_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bBack_level_joined;$/;"	m	class:Multigrid
m_data_MG_bBottom_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bBottom_level_joined;$/;"	m	class:Multigrid
m_data_MG_bFront_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bFront_level_joined;$/;"	m	class:Multigrid
m_data_MG_bLeft_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bLeft_level_joined;$/;"	m	class:Multigrid
m_data_MG_bList_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bList_level_joined;$/;"	m	class:Multigrid
m_data_MG_bRight_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bRight_level_joined;$/;"	m	class:Multigrid
m_data_MG_bTop_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_bTop_level_joined;$/;"	m	class:Multigrid
m_data_MG_iList_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_iList_level_joined;$/;"	m	class:Multigrid
m_data_MG_oBack_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oBack_level_joined;$/;"	m	class:Multigrid
m_data_MG_oBottom_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oBottom_level_joined;$/;"	m	class:Multigrid
m_data_MG_oFront_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oFront_level_joined;$/;"	m	class:Multigrid
m_data_MG_oLeft_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oLeft_level_joined;$/;"	m	class:Multigrid
m_data_MG_oList_zero_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oList_zero_joined;$/;"	m	class:Multigrid
m_data_MG_oRight_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oRight_level_joined;$/;"	m	class:Multigrid
m_data_MG_oTop_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_oTop_level_joined;$/;"	m	class:Multigrid
m_data_MG_sList_level_joined	boundary/Multigrid.h	/^    size_t* m_data_MG_sList_level_joined;$/;"	m	class:Multigrid
m_data_boundary_patches_joined	boundary/Multigrid.h	/^    size_t** m_data_boundary_patches_joined;$/;"	m	class:Multigrid
m_data_obstacles_patches_joined	boundary/Multigrid.h	/^    size_t** m_data_obstacles_patches_joined;$/;"	m	class:Multigrid
m_dir_vel	solver/NSTempConSolver.h	/^    std::string m_dir_vel;$/;"	m	class:NSTempConSolver
m_dir_vel	solver/NSTempSolver.h	/^    std::string m_dir_vel;$/;"	m	class:NSTempSolver
m_dir_vel	solver/NSTempTurbConSolver.h	/^    std::string m_dir_vel;$/;"	m	class:NSTempTurbConSolver
m_dir_vel	solver/NSTempTurbSolver.h	/^    std::string m_dir_vel;$/;"	m	class:NSTempTurbSolver
m_dir_vel	source/ExplicitEulerSource.h	/^    std::string m_dir_vel;$/;"	m	class:ExplicitEulerSource
m_domain	analysis/Solution.h	/^    const Domain &m_domain;$/;"	m	class:Solution
m_dsign	diffusion/ColoredGaussSeidelDiffuse.h	/^    real m_dsign;$/;"	m	class:ColoredGaussSeidelDiffuse
m_dsign	diffusion/JacobiDiffuse.h	/^    real m_dsign;$/;"	m	class:JacobiDiffuse
m_dsign	pressure/VCycleMG.h	/^    real m_dsign;$/;"	m	class:VCycleMG
m_dt	TimeIntegration.h	/^    real m_dt;$/;"	m	class:TimeIntegration
m_dt	advection/SLAdvect.h	/^    real m_dt;$/;"	m	class:SLAdvect
m_dt	diffusion/ColoredGaussSeidelDiffuse.h	/^    real m_dt;$/;"	m	class:ColoredGaussSeidelDiffuse
m_dt	diffusion/ExplicitDiffuse.h	/^    real m_dt;$/;"	m	class:ExplicitDiffuse
m_dt	diffusion/JacobiDiffuse.h	/^    real m_dt;$/;"	m	class:JacobiDiffuse
m_dt	source/ExplicitEulerSource.h	/^    real m_dt;$/;"	m	class:ExplicitEulerSource
m_dt	turbulence/ConstSmagorinsky.h	/^    real m_dt;$/;"	m	class:ConstSmagorinsky
m_dt	visualisation/Visual.h	/^    real m_dt;$/;"	m	class:Visual
m_dynamic	adaption/Adaption.h	/^    bool m_dynamic, m_dynamic_end;$/;"	m	class:ADTypes::Adaption
m_dynamic_end	adaption/Adaption.h	/^    bool m_dynamic, m_dynamic_end;$/;"	m	class:ADTypes::Adaption
m_expansion_size	adaption/Layers.h	/^    size_t m_no_buffer_cells, m_timestep, m_timecounter, m_expansion_size;$/;"	m	class:Layers
m_field_controller	TimeIntegration.h	/^    FieldController *m_field_controller;$/;"	m	class:TimeIntegration
m_field_controller	adaption/Adaption.h	/^    FieldController *m_field_controller;$/;"	m	class:ADTypes::Adaption
m_field_controller	solver/AdvectionDiffusionSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:AdvectionDiffusionSolver
m_field_controller	solver/AdvectionSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:AdvectionSolver
m_field_controller	solver/DiffusionSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:DiffusionSolver
m_field_controller	solver/DiffusionTurbSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:DiffusionTurbSolver
m_field_controller	solver/NSSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:NSSolver
m_field_controller	solver/NSTempConSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:NSTempConSolver
m_field_controller	solver/NSTempSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:NSTempSolver
m_field_controller	solver/NSTempTurbConSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:NSTempTurbConSolver
m_field_controller	solver/NSTempTurbSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:NSTempTurbSolver
m_field_controller	solver/NSTurbSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:NSTurbSolver
m_field_controller	solver/PressureSolver.h	/^    FieldController *m_field_controller;$/;"	m	class:PressureSolver
m_field_controller	solver/SolverController.h	/^    FieldController *m_field_controller;$/;"	m	class:SolverController
m_field_spatial_values	source/GaussFunction.h	/^    Field *m_field_spatial_values;$/;"	m	class:GaussFunction
m_filename	adaption/Adaption.h	/^    std::string m_filename;$/;"	m	class:ADTypes::Adaption
m_filename	utility/Parameters.h	/^    std::string m_filename;$/;"	m	class:Parameters
m_filename	visualisation/Visual.h	/^    std::string m_filename;$/;"	m	class:Visual
m_forceFct	solver/NSTempConSolver.h	/^    std::string m_forceFct;$/;"	m	class:NSTempConSolver
m_forceFct	solver/NSTempSolver.h	/^    std::string m_forceFct;$/;"	m	class:NSTempSolver
m_forceFct	solver/NSTempTurbConSolver.h	/^    std::string m_forceFct;$/;"	m	class:NSTempTurbConSolver
m_forceFct	solver/NSTempTurbSolver.h	/^    std::string m_forceFct;$/;"	m	class:NSTempTurbSolver
m_force_function	solver/NSTurbSolver.h	/^    std::string m_force_function;$/;"	m	class:NSTurbSolver
m_gamma	adaption/Layers.h	/^    Field *m_T, *m_Ta, *m_Nu, *m_kappa, *m_gamma;$/;"	m	class:Layers
m_gamma	solver/NSTempConSolver.h	/^    real m_gamma;$/;"	m	class:NSTempConSolver
m_gamma	solver/NSTempTurbConSolver.h	/^    real m_gamma;$/;"	m	class:NSTempTurbConSolver
m_hasDissipation	solver/NSTempConSolver.h	/^    bool m_hasDissipation;$/;"	m	class:NSTempConSolver
m_hasDissipation	solver/NSTempTurbSolver.h	/^    bool m_hasDissipation;$/;"	m	class:NSTempTurbSolver
m_hasObstacles	boundary/BoundaryController.h	/^    bool m_hasObstacles;$/;"	m	class:BoundaryController
m_hasSurfaces	boundary/BoundaryController.h	/^    bool m_hasSurfaces;$/;"	m	class:BoundaryController
m_hasTurbulence	solver/NSTempTurbSolver.h	/^    bool m_hasTurbulence;$/;"	m	class:NSTempTurbSolver
m_hasValues	boundary/BoundaryData.h	/^    bool m_hasValues = false;$/;"	m	class:BoundaryData
m_has_analytical_solution	visualisation/Visual.h	/^    bool m_has_analytical_solution = false;$/;"	m	class:Visual
m_has_concentration	solver/SolverController.h	/^    bool m_has_concentration = false;$/;"	m	class:SolverController
m_has_data_extraction	adaption/Adaption.h	/^    bool m_has_data_extraction;$/;"	m	class:ADTypes::Adaption
m_has_data_extraction_after	adaption/Adaption.h	/^    bool m_has_data_extraction_after = false;$/;"	m	class:ADTypes::Adaption
m_has_data_extraction_before	adaption/Adaption.h	/^    bool m_has_data_extraction_before = false;$/;"	m	class:ADTypes::Adaption
m_has_data_extraction_endresult	adaption/Adaption.h	/^    bool m_has_data_extraction_endresult = false;$/;"	m	class:ADTypes::Adaption
m_has_dissipation	solver/NSTempSolver.h	/^    bool m_has_dissipation;$/;"	m	class:NSTempSolver
m_has_dissipation	solver/NSTempTurbConSolver.h	/^    bool m_has_dissipation;$/;"	m	class:NSTempTurbConSolver
m_has_momentum_source	solver/SolverController.h	/^    bool m_has_momentum_source = false;$/;"	m	class:SolverController
m_has_temperature	solver/SolverController.h	/^    bool m_has_temperature = false;$/;"	m	class:SolverController
m_has_time_measuring	adaption/Adaption.h	/^    bool m_has_time_measuring = false;$/;"	m	class:ADTypes::Adaption
m_has_turbulence	solver/SolverController.h	/^    bool m_has_turbulence = false;$/;"	m	class:SolverController
m_has_turbulence_concentration	solver/NSTempTurbConSolver.h	/^    bool m_has_turbulence_concentration;$/;"	m	class:NSTempTurbConSolver
m_has_turbulence_temperature	solver/NSTempTurbConSolver.h	/^    bool m_has_turbulence_temperature;$/;"	m	class:NSTempTurbConSolver
m_has_write_runtime	adaption/Adaption.h	/^    bool m_has_write_runtime = false;$/;"	m	class:ADTypes::Adaption
m_height_after	adaption/Adaption.h	/^    real m_height_after = 0;$/;"	m	class:ADTypes::Adaption
m_height_before	adaption/Adaption.h	/^    real m_height_before = 0;$/;"	m	class:ADTypes::Adaption
m_i1	boundary/Obstacle.h	/^    size_t m_i1, m_j1, m_k1;$/;"	m	class:Obstacle
m_i1	boundary/Surface.h	/^    size_t m_i1;$/;"	m	class:Surface
m_i2	boundary/Obstacle.h	/^    size_t m_i2, m_j2, m_k2;$/;"	m	class:Obstacle
m_init_function	analysis/Solution.h	/^    void (Solution::*m_init_function)(const real);$/;"	m	class:Solution
m_innerList	boundary/Boundary.h	/^    size_t* m_innerList;$/;"	m	class:Boundary
m_j1	boundary/Obstacle.h	/^    size_t m_i1, m_j1, m_k1;$/;"	m	class:Obstacle
m_j1	boundary/Surface.h	/^    size_t m_j1;$/;"	m	class:Surface
m_j2	boundary/Obstacle.h	/^    size_t m_i2, m_j2, m_k2;$/;"	m	class:Obstacle
m_k1	boundary/Obstacle.h	/^    size_t m_i1, m_j1, m_k1;$/;"	m	class:Obstacle
m_k1	boundary/Surface.h	/^    size_t m_k1;$/;"	m	class:Surface
m_k2	boundary/Obstacle.h	/^    size_t m_i2, m_j2, m_k2;$/;"	m	class:Obstacle
m_kappa	adaption/Layers.h	/^    Field *m_T, *m_Ta, *m_Nu, *m_kappa, *m_gamma;$/;"	m	class:Layers
m_kappa	solver/NSTempConSolver.h	/^    real m_kappa;$/;"	m	class:NSTempConSolver
m_kappa	solver/NSTempSolver.h	/^    real m_kappa;$/;"	m	class:NSTempSolver
m_kappa	solver/NSTempTurbConSolver.h	/^    real m_kappa;$/;"	m	class:NSTempTurbConSolver
m_kappa	solver/NSTempTurbSolver.h	/^    real m_kappa;$/;"	m	class:NSTempTurbSolver
m_level	boundary/Boundary.h	/^    size_t m_level;$/;"	m	class:Boundary
m_level	boundary/Obstacle.h	/^    size_t m_level = 0;$/;"	m	class:Obstacle
m_level	field/Field.h	/^    size_t m_level;$/;"	m	class:Field
m_levels	Domain.h	/^    size_t m_levels = 0;$/;"	m	class:Domain
m_levels	boundary/Multigrid.h	/^    size_t m_levels;$/;"	m	class:Multigrid
m_logger	Domain.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Domain
m_logger	TimeIntegration.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:TimeIntegration
m_logger	adaption/Adaption.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:ADTypes::Adaption
m_logger	analysis/Analysis.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Analysis
m_logger	analysis/Solution.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Solution
m_logger	boundary/Boundary.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Boundary
m_logger	boundary/BoundaryController.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:BoundaryController
m_logger	boundary/BoundaryData.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:BoundaryData
m_logger	boundary/BoundaryDataController.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:BoundaryDataController
m_logger	boundary/Multigrid.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Multigrid
m_logger	boundary/Obstacle.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Obstacle
m_logger	boundary/Surface.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Surface
m_logger	diffusion/ColoredGaussSeidelDiffuse.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:ColoredGaussSeidelDiffuse
m_logger	diffusion/JacobiDiffuse.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:JacobiDiffuse
m_logger	pressure/VCycleMG.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:VCycleMG
m_logger	solver/AdvectionDiffusionSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:AdvectionDiffusionSolver
m_logger	solver/AdvectionSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:AdvectionSolver
m_logger	solver/DiffusionSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:DiffusionSolver
m_logger	solver/DiffusionTurbSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:DiffusionTurbSolver
m_logger	solver/NSSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:NSSolver
m_logger	solver/NSTempConSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:NSTempConSolver
m_logger	solver/NSTempSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:NSTempSolver
m_logger	solver/NSTempTurbConSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:NSTempTurbConSolver
m_logger	solver/NSTempTurbSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:NSTempTurbSolver
m_logger	solver/NSTurbSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:NSTurbSolver
m_logger	solver/PressureSolver.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:PressureSolver
m_logger	solver/SolverController.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:SolverController
m_logger	source/ExplicitEulerSource.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:ExplicitEulerSource
m_logger	utility/Parameters.h	/^    std::shared_ptr<spdlog::logger> m_logger;$/;"	m	class:Parameters
m_max_iter	diffusion/ColoredGaussSeidelDiffuse.h	/^    size_t m_max_iter;$/;"	m	class:ColoredGaussSeidelDiffuse
m_max_iter	diffusion/JacobiDiffuse.h	/^    size_t m_max_iter;$/;"	m	class:JacobiDiffuse
m_minimal	adaption/Adaption.h	/^    size_t m_minimal;$/;"	m	class:ADTypes::Adaption
m_minimal	adaption/Layers.h	/^    size_t m_minimal;$/;"	m	class:Layers
m_minimal	adaption/Vortex.h	/^    size_t m_minimal;$/;"	m	class:Vortex
m_multigrid	boundary/BoundaryController.h	/^    Multigrid* m_multigrid;$/;"	m	class:BoundaryController
m_no_buffer_cells	adaption/Layers.h	/^    size_t m_no_buffer_cells, m_timestep, m_timecounter, m_expansion_size;$/;"	m	class:Layers
m_nu	solver/AdvectionDiffusionSolver.h	/^    real m_nu;$/;"	m	class:AdvectionDiffusionSolver
m_nu	solver/DiffusionSolver.h	/^    real m_nu;$/;"	m	class:DiffusionSolver
m_nu	solver/DiffusionTurbSolver.h	/^    real m_nu;$/;"	m	class:DiffusionTurbSolver
m_nu	solver/NSSolver.h	/^    real m_nu;$/;"	m	class:NSSolver
m_nu	solver/NSTempConSolver.h	/^    real m_nu;$/;"	m	class:NSTempConSolver
m_nu	solver/NSTempSolver.h	/^    real m_nu;$/;"	m	class:NSTempSolver
m_nu	solver/NSTempTurbConSolver.h	/^    real m_nu;$/;"	m	class:NSTempTurbConSolver
m_nu	solver/NSTempTurbSolver.h	/^    real m_nu;$/;"	m	class:NSTempTurbSolver
m_nu	solver/NSTurbSolver.h	/^    real m_nu;$/;"	m	class:NSTurbSolver
m_nu	turbulence/ConstSmagorinsky.h	/^    real m_nu;$/;"	m	class:ConstSmagorinsky
m_nu	turbulence/DynamicSmagorinsky.h	/^    real m_nu;                        \/\/ viscosity$/;"	m	class:DynamicSmagorinsky
m_numberOfObstacles	boundary/BoundaryController.h	/^    size_t m_numberOfObstacles = 0;$/;"	m	class:BoundaryController
m_numberOfObstacles	boundary/Multigrid.h	/^    size_t m_numberOfObstacles = 0;$/;"	m	class:Multigrid
m_numberOfSurfaces	boundary/BoundaryController.h	/^    size_t m_numberOfSurfaces = 0;$/;"	m	class:BoundaryController
m_numberOfSurfaces	boundary/Multigrid.h	/^    size_t m_numberOfSurfaces = 0;$/;"	m	class:Multigrid
m_nx	Domain.h	/^    size_t *m_nx, *m_ny, *m_nz;$/;"	m	class:Domain
m_nx	adaption/Layers.h	/^    size_t m_nx, m_ny, m_nz;$/;"	m	class:Layers
m_ny	Domain.h	/^    size_t *m_nx, *m_ny, *m_nz;$/;"	m	class:Domain
m_ny	adaption/Layers.h	/^    size_t m_nx, m_ny, m_nz;$/;"	m	class:Layers
m_nz	Domain.h	/^    size_t *m_nx, *m_ny, *m_nz;$/;"	m	class:Domain
m_nz	adaption/Layers.h	/^    size_t m_nx, m_ny, m_nz;$/;"	m	class:Layers
m_obstacleBack	boundary/Obstacle.h	/^    size_t* m_obstacleBack;$/;"	m	class:Obstacle
m_obstacleBottom	boundary/Obstacle.h	/^    size_t* m_obstacleBottom;$/;"	m	class:Obstacle
m_obstacleFront	boundary/Obstacle.h	/^    size_t* m_obstacleFront;$/;"	m	class:Obstacle
m_obstacleLeft	boundary/Obstacle.h	/^    size_t* m_obstacleLeft;$/;"	m	class:Obstacle
m_obstacleList	boundary/BoundaryController.h	/^    Obstacle** m_obstacleList;$/;"	m	class:BoundaryController
m_obstacleList	boundary/Obstacle.h	/^    size_t* m_obstacleList;$/;"	m	class:Obstacle
m_obstacleRight	boundary/Obstacle.h	/^    size_t* m_obstacleRight;$/;"	m	class:Obstacle
m_obstacleTop	boundary/Obstacle.h	/^    size_t* m_obstacleTop;$/;"	m	class:Obstacle
m_reduction	adaption/Vortex.h	/^    bool m_reduction;$/;"	m	class:Vortex
m_save_csv	visualisation/Visual.h	/^    bool m_save_csv = false;$/;"	m	class:Visual
m_save_vtk	visualisation/Visual.h	/^    bool m_save_vtk = false;$/;"	m	class:Visual
m_shift_x1	adaption/Adaption.h	/^    long m_shift_x1, m_shift_x2, m_shift_y1, m_shift_y2, m_shift_z1, m_shift_z2;$/;"	m	class:ADTypes::Adaption
m_shift_x2	adaption/Adaption.h	/^    long m_shift_x1, m_shift_x2, m_shift_y1, m_shift_y2, m_shift_z1, m_shift_z2;$/;"	m	class:ADTypes::Adaption
m_shift_y1	adaption/Adaption.h	/^    long m_shift_x1, m_shift_x2, m_shift_y1, m_shift_y2, m_shift_z1, m_shift_z2;$/;"	m	class:ADTypes::Adaption
m_shift_y2	adaption/Adaption.h	/^    long m_shift_x1, m_shift_x2, m_shift_y1, m_shift_y2, m_shift_z1, m_shift_z2;$/;"	m	class:ADTypes::Adaption
m_shift_z1	adaption/Adaption.h	/^    long m_shift_x1, m_shift_x2, m_shift_y1, m_shift_y2, m_shift_z1, m_shift_z2;$/;"	m	class:ADTypes::Adaption
m_shift_z2	adaption/Adaption.h	/^    long m_shift_x1, m_shift_x2, m_shift_y1, m_shift_y2, m_shift_z1, m_shift_z2;$/;"	m	class:ADTypes::Adaption
m_size	field/Field.h	/^    size_t m_size;$/;"	m	class:Field
m_size_MG_bList_level	boundary/Multigrid.h	/^    size_t* m_size_MG_bList_level;$/;"	m	class:Multigrid
m_size_MG_bSliceX_level	boundary/Multigrid.h	/^    size_t* m_size_MG_bSliceX_level;$/;"	m	class:Multigrid
m_size_MG_bSliceY_level	boundary/Multigrid.h	/^    size_t* m_size_MG_bSliceY_level;$/;"	m	class:Multigrid
m_size_MG_bSliceZ_level	boundary/Multigrid.h	/^    size_t* m_size_MG_bSliceZ_level;$/;"	m	class:Multigrid
m_size_MG_iList_level	boundary/Multigrid.h	/^    size_t* m_size_MG_iList_level;$/;"	m	class:Multigrid
m_size_MG_oBack_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oBack_level;$/;"	m	class:Multigrid
m_size_MG_oBottom_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oBottom_level;$/;"	m	class:Multigrid
m_size_MG_oFront_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oFront_level;$/;"	m	class:Multigrid
m_size_MG_oLeft_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oLeft_level;$/;"	m	class:Multigrid
m_size_MG_oList_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oList_level;$/;"	m	class:Multigrid
m_size_MG_oRight_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oRight_level;$/;"	m	class:Multigrid
m_size_MG_oTop_level	boundary/Multigrid.h	/^    size_t* m_size_MG_oTop_level;$/;"	m	class:Multigrid
m_size_MG_sList_level	boundary/Multigrid.h	/^    size_t* m_size_MG_sList_level;$/;"	m	class:Multigrid
m_size_boundaryBack	boundary/Boundary.h	/^    size_t m_size_boundaryBack;$/;"	m	class:Boundary
m_size_boundaryBottom	boundary/Boundary.h	/^    size_t m_size_boundaryBottom;$/;"	m	class:Boundary
m_size_boundaryFront	boundary/Boundary.h	/^    size_t m_size_boundaryFront;$/;"	m	class:Boundary
m_size_boundaryLeft	boundary/Boundary.h	/^    size_t m_size_boundaryLeft;$/;"	m	class:Boundary
m_size_boundaryList	boundary/Boundary.h	/^    size_t m_size_boundaryList;$/;"	m	class:Boundary
m_size_boundaryRight	boundary/Boundary.h	/^    size_t m_size_boundaryRight;$/;"	m	class:Boundary
m_size_boundaryTop	boundary/Boundary.h	/^    size_t m_size_boundaryTop;$/;"	m	class:Boundary
m_size_innerList	boundary/Boundary.h	/^    size_t m_size_innerList;$/;"	m	class:Boundary
m_size_obstacleBack	boundary/Obstacle.h	/^    size_t m_size_obstacleBack;$/;"	m	class:Obstacle
m_size_obstacleBottom	boundary/Obstacle.h	/^    size_t m_size_obstacleBottom;$/;"	m	class:Obstacle
m_size_obstacleFront	boundary/Obstacle.h	/^    size_t m_size_obstacleFront;$/;"	m	class:Obstacle
m_size_obstacleLeft	boundary/Obstacle.h	/^    size_t m_size_obstacleLeft;$/;"	m	class:Obstacle
m_size_obstacleList	boundary/Obstacle.h	/^    size_t m_size_obstacleList;$/;"	m	class:Obstacle
m_size_obstacleRight	boundary/Obstacle.h	/^    size_t m_size_obstacleRight;$/;"	m	class:Obstacle
m_size_obstacleTop	boundary/Obstacle.h	/^    size_t m_size_obstacleTop;$/;"	m	class:Obstacle
m_size_sList	boundary/BoundaryController.h	/^    size_t m_size_sList = 0;$/;"	m	class:BoundaryController
m_size_surfaceList	boundary/Surface.h	/^    size_t m_size_surfaceList;$/;"	m	class:Surface
m_solution	TimeIntegration.h	/^    Solution *m_solution;$/;"	m	class:TimeIntegration
m_solution	analysis/Analysis.h	/^    Solution *m_solution;$/;"	m	class:Analysis
m_solution	visualisation/Visual.h	/^    Solution *m_solution;$/;"	m	class:Visual
m_solver	solver/SolverController.h	/^    ISolver *m_solver;$/;"	m	class:SolverController
m_solver_controller	TimeIntegration.h	/^    SolverController *m_solver_controller;$/;"	m	class:TimeIntegration
m_sourceFct	solver/NSSolver.h	/^    std::string m_sourceFct;$/;"	m	class:NSSolver
m_source_field	source/BuoyancyMMS.h	/^    Field *m_source_field;$/;"	m	class:BuoyancyMMS
m_source_field	source/Cube.h	/^    Field *m_source_field;$/;"	m	class:Cube
m_source_function_concentration	solver/SolverController.h	/^    ISourceFunction *m_source_function_concentration;$/;"	m	class:SolverController
m_source_function_temperature	solver/SolverController.h	/^    ISourceFunction *m_source_function_temperature;$/;"	m	class:SolverController
m_strideX	boundary/Surface.h	/^    size_t m_strideX;$/;"	m	class:Surface
m_strideY	boundary/Surface.h	/^    size_t m_strideY;$/;"	m	class:Surface
m_strideZ	boundary/Surface.h	/^    size_t m_strideZ;$/;"	m	class:Surface
m_surfaceID	boundary/Surface.h	/^    size_t m_surfaceID;$/;"	m	class:Surface
m_surfaceList	boundary/BoundaryController.h	/^    Surface** m_surfaceList;$/;"	m	class:BoundaryController
m_surfaceList	boundary/Surface.h	/^    size_t *m_surfaceList;  \/\/ indices of surface$/;"	m	class:Surface
m_t_cur	TimeIntegration.h	/^    real m_t_cur;$/;"	m	class:TimeIntegration
m_t_end	TimeIntegration.h	/^    real m_t_end;$/;"	m	class:TimeIntegration
m_t_end	visualisation/Visual.h	/^    real m_t_end;$/;"	m	class:Visual
m_tau	source/GaussFunction.h	/^    real m_tau;$/;"	m	class:GaussFunction
m_tempFct	solver/NSTempConSolver.h	/^    std::string m_tempFct;$/;"	m	class:NSTempConSolver
m_tempFct	solver/NSTempSolver.h	/^    std::string m_tempFct;$/;"	m	class:NSTempSolver
m_tempFct	solver/NSTempTurbConSolver.h	/^    std::string m_tempFct;$/;"	m	class:NSTempTurbConSolver
m_tempFct	solver/NSTempTurbSolver.h	/^    std::string m_tempFct;$/;"	m	class:NSTempTurbSolver
m_threshold	adaption/Vortex.h	/^    real m_threshold;$/;"	m	class:Vortex
m_timecounter	adaption/Layers.h	/^    size_t m_no_buffer_cells, m_timestep, m_timecounter, m_expansion_size;$/;"	m	class:Layers
m_timestep	adaption/Layers.h	/^    size_t m_no_buffer_cells, m_timestep, m_timecounter, m_expansion_size;$/;"	m	class:Layers
m_tol	analysis/Analysis.h	/^    real m_tol = 1e-7;$/;"	m	class:Analysis
m_tol_res	diffusion/ColoredGaussSeidelDiffuse.h	/^    real m_tol_res;$/;"	m	class:ColoredGaussSeidelDiffuse
m_tol_res	diffusion/JacobiDiffuse.h	/^    real m_tol_res;$/;"	m	class:JacobiDiffuse
m_type	field/Field.h	/^    FieldType m_type;$/;"	m	class:Field
m_u_lin	adaption/Vortex.h	/^    real m_u_lin;$/;"	m	class:Vortex
m_v_lin	adaption/Vortex.h	/^    real m_v_lin;$/;"	m	class:Vortex
m_values	boundary/BoundaryData.h	/^    real* m_values;$/;"	m	class:BoundaryData
m_visual	TimeIntegration.h	/^    Visual *m_visual;$/;"	m	class:TimeIntegration
m_vtk_plots	visualisation/Visual.h	/^    int m_vtk_plots = 0;$/;"	m	class:Visual
m_w	diffusion/ColoredGaussSeidelDiffuse.h	/^    real m_w;$/;"	m	class:ColoredGaussSeidelDiffuse
m_w	diffusion/JacobiDiffuse.h	/^    real m_w;$/;"	m	class:JacobiDiffuse
m_w	pressure/VCycleMG.h	/^    real m_w;$/;"	m	class:VCycleMG
m_w_lin	adaption/Vortex.h	/^    real m_w_lin;$/;"	m	class:Vortex
m_x1	Domain.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Domain
m_x1	adaption/Layers.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Layers
m_x2	Domain.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Domain
m_x2	adaption/Layers.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Layers
m_x_side	adaption/Vortex.h	/^    bool m_x_side = false;$/;"	m	class:Vortex
m_y1	Domain.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Domain
m_y1	adaption/Layers.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Layers
m_y2	Domain.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Domain
m_y2	adaption/Layers.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Layers
m_y_side	adaption/Vortex.h	/^    bool m_y_side = false;$/;"	m	class:Vortex
m_z1	Domain.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Domain
m_z1	adaption/Layers.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Layers
m_z2	Domain.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Domain
m_z2	adaption/Layers.h	/^    real m_x1, m_x2, m_y1, m_y2, m_z1, m_z2;$/;"	m	class:Layers
m_z_side	adaption/Vortex.h	/^    bool m_z_side = false;$/;"	m	class:Vortex
main	main.cpp	/^int main(int argc, char **argv) {$/;"	f
matchBoundaryCondition	boundary/BoundaryData.cpp	/^BoundaryCondition BoundaryData::matchBoundaryCondition(const std::string &s) {$/;"	f	class:BoundaryData
matchField	boundary/BoundaryData.cpp	/^FieldType BoundaryData::matchField(const std::string &s) {$/;"	f	class:BoundaryData
matchGrid	boundary/Obstacle.cpp	/^real Obstacle::matchGrid(double obstacleCoordinate, real spacing, real startCoordinate) {$/;"	f	class:Obstacle
matchPatch	boundary/BoundaryData.cpp	/^Patch BoundaryData::matchPatch(const std::string &s) {$/;"	f	class:BoundaryData
mcDermott	analysis/Solution.cpp	/^void Solution::mcDermott(const real t) {$/;"	f	class:Solution
mem	utility/tinyxml2.h	/^        char    mem[SIZE];$/;"	m	union:tinyxml2::MemPoolT::Chunk
mg_temporal_solution	pressure/VCycleMG.h	/^    std::vector<Field*> mg_temporal_solution;$/;"	m	class:VCycleMG
momentum_source	solver/SolverController.cpp	/^void SolverController::momentum_source() {$/;"	f	class:SolverController
mu_tub	solver/DiffusionTurbSolver.h	/^    ITurbulence *mu_tub;$/;"	m	class:DiffusionTurbSolver
mu_tub	solver/NSTempTurbConSolver.h	/^    ITurbulence *mu_tub;$/;"	m	class:NSTempTurbConSolver
mu_tub	solver/NSTempTurbSolver.h	/^    ITurbulence *mu_tub;$/;"	m	class:NSTempTurbSolver
mu_tub	solver/NSTurbSolver.h	/^    ITurbulence *mu_tub;$/;"	m	class:NSTurbSolver
new_section	visualisation/visit_writer.cpp	/^static void new_section(void)$/;"	f	file:
next	utility/tinyxml2.h	/^        Chunk*  next;$/;"	m	union:tinyxml2::MemPoolT::Chunk
numInColumn	visualisation/visit_writer.cpp	/^static int numInColumn = 0;$/;"	v	file:
num_points_for_cell	visualisation/visit_writer.cpp	/^static int num_points_for_cell(int celltype)$/;"	f	file:
numberOfBoundaryConditions	boundary/BoundaryData.h	/^const size_t numberOfBoundaryConditions = 3;$/;"	v
numberOfFieldTypes	field/Field.h	/^const size_t numberOfFieldTypes = 6;$/;"	v
numberOfPatches	boundary/BoundaryData.h	/^const size_t numberOfPatches = 6;$/;"	v
obstacleDominantRestriction	boundary/Multigrid.cpp	/^Obstacle **Multigrid::obstacleDominantRestriction(size_t level) {$/;"	f	class:Multigrid
open_file	visualisation/visit_writer.cpp	/^static void open_file(const char *filename)$/;"	f	file:
operator =	utility/tinyxml2.h	/^    XMLConstHandle& operator=( const XMLConstHandle& ref )							{$/;"	f	class:tinyxml2::XMLConstHandle
operator =	utility/tinyxml2.h	/^    XMLHandle& operator=( const XMLHandle& ref )							{$/;"	f	class:tinyxml2::XMLHandle
operator []	field/Field.h	/^    real& operator[](size_t i) { return data[i]; }$/;"	f	class:Field
operator []	utility/tinyxml2.h	/^    T& operator[](int i)				{$/;"	f	class:tinyxml2::DynArray
operator []	utility/tinyxml2.h	/^    const T& operator[](int i) const	{$/;"	f	class:tinyxml2::DynArray
override	adaption/Layers.h	/^    bool update(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) override;$/;"	m	class:Layers
override	adaption/Layers.h	/^    void apply_changes(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) override;$/;"	m	class:Layers
override	adaption/Vortex.h	/^    bool has_reduction() override;$/;"	m	class:Vortex
override	adaption/Vortex.h	/^    bool update(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) override;$/;"	m	class:Vortex
override	adaption/Vortex.h	/^    void apply_changes(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) override;$/;"	m	class:Vortex
override	advection/SLAdvect.h	/^    void advect(Field *out, Field *in, const Field *u_vel, const Field *v_vel, const Field *w_vel, bool sync) override;$/;"	m	class:SLAdvect
override	advection/SLAdvect.h	/^    ~SLAdvect() override = default;$/;"	m	class:SLAdvect
override	diffusion/ExplicitDiffuse.h	/^    void diffuse(Field *out, Field *in, const Field *b, real D, bool sync) override;$/;"	m	class:ExplicitDiffuse
override	diffusion/ExplicitDiffuse.h	/^    void diffuse(Field *out, Field *in, const Field *b, real D, const Field *EV, bool sync) override;  \/\/ turbulent version$/;"	m	class:ExplicitDiffuse
override	diffusion/JacobiDiffuse.h	/^    void diffuse(Field *out, Field *in, const Field *b, real D, bool sync) override;$/;"	m	class:JacobiDiffuse
override	diffusion/JacobiDiffuse.h	/^    void diffuse(Field *out, Field *in, const Field *b, real D, const Field *EV, bool sync) override;  \/\/ turbulent version$/;"	m	class:JacobiDiffuse
override	pressure/VCycleMG.h	/^    ~VCycleMG() override;$/;"	m	class:VCycleMG
override	solver/AdvectionDiffusionSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:AdvectionDiffusionSolver
override	solver/AdvectionSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:AdvectionSolver
override	solver/DiffusionSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:DiffusionSolver
override	solver/DiffusionTurbSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:DiffusionTurbSolver
override	solver/NSSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:NSSolver
override	solver/NSTempConSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:NSTempConSolver
override	solver/NSTempConSolver.h	/^    ~NSTempConSolver() override;$/;"	m	class:NSTempConSolver
override	solver/NSTempSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:NSTempSolver
override	solver/NSTempTurbConSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:NSTempTurbConSolver
override	solver/NSTempTurbSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:NSTempTurbSolver
override	solver/NSTurbSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:NSTurbSolver
override	solver/PressureSolver.h	/^    void do_step(real t, bool sync) override;$/;"	m	class:PressureSolver
override	source/BuoyancyMMS.h	/^    void update_source(Field *out, real t_cur) override;$/;"	m	class:BuoyancyMMS
override	source/Cube.h	/^    void update_source(Field *out, real t_cur) override;$/;"	m	class:Cube
override	source/ExplicitEulerSource.h	/^    void add_source(Field* out, Field* S, bool sync) override;$/;"	m	class:ExplicitEulerSource
override	source/ExplicitEulerSource.h	/^    void add_source(Field* out_x, Field* out_y, Field* out_z, Field* S_x, Field* S_y, Field* S_z, bool sync) override;$/;"	m	class:ExplicitEulerSource
override	source/GaussFunction.h	/^    void update_source(Field *out, real t_cur) override;$/;"	m	class:GaussFunction
override	turbulence/ConstSmagorinsky.h	/^    void CalcTurbViscosity(Field *ev, Field *in_u, Field *in_v, Field *in_w, bool sync) override;$/;"	m	class:ConstSmagorinsky
override	turbulence/ConstSmagorinsky.h	/^    void ExplicitFiltering(Field *out, const Field *in, bool sync) override;$/;"	m	class:ConstSmagorinsky
override	turbulence/ConstSmagorinsky.h	/^    ~ConstSmagorinsky() override = default;$/;"	m	class:ConstSmagorinsky
override	turbulence/DynamicSmagorinsky.h	/^    void CalcTurbViscosity(Field *ev, Field *in_u, Field *in_v, Field *in_w, bool sync) override;$/;"	m	class:DynamicSmagorinsky
override	turbulence/DynamicSmagorinsky.h	/^    void ExplicitFiltering(Field *out, const Field *in, bool sync) override;$/;"	m	class:DynamicSmagorinsky
override	turbulence/DynamicSmagorinsky.h	/^    ~DynamicSmagorinsky() override;$/;"	m	class:DynamicSmagorinsky
p_a	analysis/Solution.h	/^    Field p_a;$/;"	m	class:Solution
parse	utility/Parameters.cpp	/^void Parameters::parse(const std::string& filename) {$/;"	f	class:Parameters
parseBoundaryParameter	boundary/BoundaryController.cpp	/^void BoundaryController::parseBoundaryParameter(tinyxml2::XMLElement *xmlParameter) {$/;"	f	class:BoundaryController
parseObstacleParameter	boundary/BoundaryController.cpp	/^void BoundaryController::parseObstacleParameter(tinyxml2::XMLElement *xmlParameter) {$/;"	f	class:BoundaryController
parseSurfaceParameter	boundary/BoundaryController.cpp	/^void BoundaryController::parseSurfaceParameter(tinyxml2::XMLElement *xmlParameter) {$/;"	f	class:BoundaryController
pattern	utility/tinyxml2.cpp	/^    const char* pattern;$/;"	m	struct:tinyxml2::Entity	file:
prepare_fields	visualisation/Visual.cpp	/^void Visual::prepare_fields(read_ptr *fields, float **vars, int size) {$/;"	f	class:Visual
pres	solver/NSSolver.h	/^    IPressure *pres;$/;"	m	class:NSSolver
pres	solver/NSTempConSolver.h	/^    IPressure *pres;$/;"	m	class:NSTempConSolver
pres	solver/NSTempSolver.h	/^    IPressure *pres;$/;"	m	class:NSTempSolver
pres	solver/NSTempTurbConSolver.h	/^    IPressure *pres;$/;"	m	class:NSTempTurbConSolver
pres	solver/NSTempTurbSolver.h	/^    IPressure *pres;$/;"	m	class:NSTempTurbSolver
pres	solver/NSTurbSolver.h	/^    IPressure *pres;$/;"	m	class:NSTurbSolver
pres	solver/PressureSolver.h	/^    IPressure *pres;$/;"	m	class:PressureSolver
pressure	pressure/VCycleMG.cpp	/^void VCycleMG::pressure(Field *out, Field *b, real t, bool sync) {$/;"	f	class:VCycleMG
print	Domain.cpp	/^void Domain::print() {$/;"	f	class:Domain
print	boundary/Boundary.cpp	/^void Boundary::print(size_t size_obstacles) {$/;"	f	class:Boundary
print	boundary/BoundaryData.cpp	/^void BoundaryData::print() {$/;"	f	class:BoundaryData
print	boundary/BoundaryDataController.cpp	/^void BoundaryDataController::print() {$/;"	f	class:BoundaryDataController
print	boundary/Multigrid.cpp	/^void Multigrid::print() {$/;"	f	class:Multigrid
print	boundary/Obstacle.cpp	/^void Obstacle::print() {$/;"	f	class:Obstacle
print	boundary/Surface.cpp	/^void Surface::print() {$/;"	f	class:Surface
printAllXMLAttributes	utility/Parameters.cpp	/^void Parameters::printAllXMLAttributes(std::string prefix, tinyxml2::XMLElement *elem) {$/;"	f	class:Parameters
printBoundaries	boundary/BoundaryController.cpp	/^void BoundaryController::printBoundaries() {$/;"	f	class:BoundaryController
printDetails	Domain.cpp	/^void Domain::printDetails() {$/;"	f	class:Domain
printDetails	boundary/Obstacle.cpp	/^void Obstacle::printDetails(){$/;"	f	class:Obstacle
projection	interfaces/IPressure.cpp	/^void IPressure::projection(Field *out_u, Field *out_v, Field *out_w, const Field *in_u, const Field *in_v, const Field *in_w, const Field *in_p, bool sync) {$/;"	f	class:IPressure
readXML	boundary/BoundaryController.cpp	/^void BoundaryController::readXML() {$/;"	f	class:BoundaryController
reduce_x_direction	adaption/Adaption.cpp	/^void Adaption::reduce_x_direction(long shift, bool start, size_t *arr_idx_reduction, size_t len_r) {$/;"	f	class:Adaption
reduce_y_Direction	adaption/Adaption.cpp	/^void Adaption::reduce_y_Direction(long shift, bool start, size_t *arr_idx_reduction, size_t len_r) {$/;"	f	class:Adaption
relaxs	pressure/VCycleMG.h	/^    int relaxs;$/;"	m	class:VCycleMG
removeBoundaryListsFromGPU	boundary/Multigrid.cpp	/^void Multigrid::removeBoundaryListsFromGPU(){$/;"	f	class:Multigrid
removeCellsAtBoundary	boundary/Obstacle.cpp	/^void Obstacle::removeCellsAtBoundary(size_t level) {$/;"	f	class:Obstacle
remove_extension	visualisation/Visual.cpp	/^std::string Visual::remove_extension(const std::string &filename) {$/;"	f	class:Visual
residuum0	pressure/VCycleMG.h	/^    std::vector<Field*> residuum0;$/;"	m	class:VCycleMG
residuum1	pressure/VCycleMG.h	/^    std::vector<Field*> residuum1;$/;"	m	class:VCycleMG
resize	Domain.cpp	/^bool Domain::resize(long shift_x1, long shift_x2, long shift_y1, long shift_y2, long shift_z1, long shift_z2) {$/;"	f	class:Domain
run	TimeIntegration.cpp	/^void TimeIntegration::run() {$/;"	f	class:TimeIntegration
run	adaption/Adaption.cpp	/^void Adaption::run(real t_cur) {$/;"	f	class:Adaption
save_variables_in_file	analysis/Analysis.cpp	/^void Analysis::save_variables_in_file(FieldController *field_controller) {$/;"	f	class:Analysis
sendBoundaryListsToGPU	boundary/Multigrid.cpp	/^void Multigrid::sendBoundaryListsToGPU() {$/;"	f	class:Multigrid
sendListsToGPU	boundary/Multigrid.cpp	/^void Multigrid::sendListsToGPU() {$/;"	f	class:Multigrid
sendObstacleListsToGPU	boundary/Multigrid.cpp	/^void Multigrid::sendObstacleListsToGPU() {$/;"	f	class:Multigrid
sendSurfaceListsToGPU	boundary/Multigrid.cpp	/^void Multigrid::sendSurfaceListsToGPU() {$/;"	f	class:Multigrid
setBoundaryConditions	boundary/Surface.cpp	/^void Surface::setBoundaryConditions(tinyxml2::XMLElement *xmlElement) {$/;"	f	class:Surface
setXValues	adaption/Layers.cpp	/^void Layers::setXValues(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2, bool start) {$/;"	f	class:Layers
set_new_value	Domain.cpp	/^bool Domain::set_new_value(long shift, real startCoord_p, real endCoord_p, real oldCoord, real cell_width, real *newCoord) {$/;"	f	class:Domain
set_up	source/BuoyancyMMS.cpp	/^void BuoyancyMMS::set_up() {$/;"	f	class:BuoyancyMMS
set_up	source/Cube.cpp	/^void Cube::set_up(real value, real x_start, real y_start, real z_start, real x_end, real y_end, real z_end) {$/;"	f	class:Cube
set_up_boundary	field/FieldController.cpp	/^void FieldController::set_up_boundary() {$/;"	f	class:FieldController
set_up_fields	solver/SolverController.cpp	/^void SolverController::set_up_fields(const std::string &string_solver) {$/;"	f	class:SolverController
set_up_sources	solver/SolverController.cpp	/^void SolverController::set_up_sources(const std::string &string_solver) {$/;"	f	class:SolverController
set_up_temporary_fields	field/FieldController.cpp	/^void FieldController::set_up_temporary_fields() {$/;"	f	class:FieldController
set_value	field/Field.h	/^    void set_value(real val) { std::fill(data, data + m_size, val); }$/;"	f	class:Field
sight	field/FieldController.h	/^    Field *sight;$/;"	m	class:FieldController
sin_sin_sin	analysis/Solution.cpp	/^void Solution::sin_sin_sin(real t) {$/;"	f	class:Solution
single	Domain.cpp	/^Domain *Domain::single = nullptr; \/\/Singleton$/;"	m	class:Domain	file:
single	Domain.h	/^    static Domain *single; \/\/Singleton$/;"	m	class:Domain
single	utility/Parameters.cpp	/^Parameters *Parameters::single = nullptr;$/;"	m	class:Parameters	file:
single	utility/Parameters.h	/^    static Parameters* single;$/;"	m	class:Parameters
singleton	boundary/BoundaryController.cpp	/^BoundaryController *BoundaryController::singleton = nullptr; \/\/ Singleton$/;"	m	class:BoundaryController	file:
singleton	boundary/BoundaryController.h	/^    static BoundaryController* singleton;$/;"	m	class:BoundaryController
solver_do_step	solver/SolverController.cpp	/^void SolverController::solver_do_step(real t, bool sync) {$/;"	f	class:SolverController
solver_selection_name	solver/SolverSelection.cpp	/^static const std::string solver_selection_name = "SolverSelection";$/;"	m	namespace:SolverSelection	file:
sou	solver/NSSolver.h	/^    ISource *sou;$/;"	m	class:NSSolver
sou_con	solver/NSTempConSolver.h	/^    ISource *sou_con;$/;"	m	class:NSTempConSolver
sou_con	solver/NSTempTurbConSolver.h	/^    ISource *sou_con;$/;"	m	class:NSTempTurbConSolver
sou_temp	solver/NSTempConSolver.h	/^    ISource *sou_temp;$/;"	m	class:NSTempConSolver
sou_temp	solver/NSTempSolver.h	/^    ISource *sou_temp;$/;"	m	class:NSTempSolver
sou_temp	solver/NSTempTurbConSolver.h	/^    ISource *sou_temp;$/;"	m	class:NSTempTurbConSolver
sou_temp	solver/NSTempTurbSolver.h	/^    ISource *sou_temp;$/;"	m	class:NSTempTurbSolver
sou_vel	solver/NSTempConSolver.h	/^    ISource *sou_vel;$/;"	m	class:NSTempConSolver
sou_vel	solver/NSTempSolver.h	/^    ISource *sou_vel;$/;"	m	class:NSTempSolver
sou_vel	solver/NSTempTurbConSolver.h	/^    ISource *sou_vel;$/;"	m	class:NSTempTurbConSolver
sou_vel	solver/NSTempTurbSolver.h	/^    ISource *sou_vel;$/;"	m	class:NSTempTurbSolver
sou_vel	solver/NSTurbSolver.h	/^    ISource *sou_vel;$/;"	m	class:NSTurbSolver
source_concentration	solver/SolverController.h	/^    ISource *source_concentration;$/;"	m	class:SolverController
source_temperature	solver/SolverController.h	/^    ISource *source_temperature;$/;"	m	class:SolverController
source_velocity	solver/SolverController.h	/^    ISource *source_velocity;$/;"	m	class:SolverController
split	utility/Utility.cpp	/^std::vector<std::string> split(const char *text, char delimiter) {$/;"	f	namespace:Utility
split	utility/Utility.cpp	/^std::vector<std::string> split(const std::string &text, char delimiter) {$/;"	f	namespace:Utility
surfaceDominantRestriction	boundary/Multigrid.cpp	/^void Multigrid::surfaceDominantRestriction(size_t level) {$/;"	f	class:Multigrid
swap	field/Field.h	/^    static void swap(Field *a, Field *b) { std::swap(a->data, b->data); }$/;"	f	class:Field
temperature_source	solver/SolverController.cpp	/^void SolverController::temperature_source() {$/;"	f	class:SolverController
tinyxml2	utility/tinyxml2.cpp	/^namespace tinyxml2$/;"	n	file:
tinyxml2	utility/tinyxml2.h	/^namespace tinyxml2$/;"	n
tn	utility/GlobalMacrosTypes.h	79;"	d
u	adaption/Vortex.h	/^    Field *u, *v, *w;$/;"	m	class:Vortex
u_a	analysis/Solution.h	/^    Field u_a, v_a, w_a;$/;"	m	class:Solution
u_f	turbulence/DynamicSmagorinsky.h	/^    Field *u_f, *v_f, *w_f;                 \/\/ filtered velocities$/;"	m	class:DynamicSmagorinsky
u_linm	solver/AdvectionSolver.h	/^    Field *u_linm;$/;"	m	class:AdvectionSolver
uf_uf	turbulence/DynamicSmagorinsky.h	/^    Field *uf_uf, *vf_vf, *wf_wf, *uf_vf, *uf_wf, *vf_wf; \/\/ product of the filtered velocities$/;"	m	class:DynamicSmagorinsky
uf_vf	turbulence/DynamicSmagorinsky.h	/^    Field *uf_uf, *vf_vf, *wf_wf, *uf_vf, *uf_wf, *vf_wf; \/\/ product of the filtered velocities$/;"	m	class:DynamicSmagorinsky
uf_wf	turbulence/DynamicSmagorinsky.h	/^    Field *uf_uf, *vf_vf, *wf_wf, *uf_vf, *uf_wf, *vf_wf; \/\/ product of the filtered velocities$/;"	m	class:DynamicSmagorinsky
update	adaption/Layers.cpp	/^bool Layers::update(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) {$/;"	f	class:Layers
update	adaption/Vortex.cpp	/^bool Vortex::update(long *p_shift_x1, long *p_shift_x2, long *p_shift_y1, long *p_shift_y2, long *p_shift_z1, long *p_shift_z2) {$/;"	f	class:Vortex
updateLists	boundary/Boundary.cpp	/^void Boundary::updateLists() {$/;"	f	class:Boundary
updateLists	boundary/Boundary.cpp	/^void Boundary::updateLists(Obstacle** obstacleList, size_t numberOfObstacles, size_t size_obstacles) {$/;"	f	class:Boundary
updateLists	boundary/BoundaryController.cpp	/^void BoundaryController::updateLists() {$/;"	f	class:BoundaryController
updateLists	boundary/Multigrid.cpp	/^void Multigrid::updateLists() {$/;"	f	class:Multigrid
update_data	field/FieldController.cpp	/^void FieldController::update_data(bool sync) {$/;"	f	class:FieldController
update_dev	field/Field.h	/^    void update_dev() {$/;"	f	class:Field
update_device	field/FieldController.cpp	/^void FieldController::update_device() {$/;"	f	class:FieldController
update_host	field/Field.h	/^    void update_host() {$/;"	f	class:Field
update_host	field/FieldController.cpp	/^void FieldController::update_host(){$/;"	f	class:FieldController
update_source	source/BuoyancyMMS.cpp	/^void BuoyancyMMS::update_source(Field *out, real t_cur) {$/;"	f	class:BuoyancyMMS
update_source	source/Cube.cpp	/^void Cube::update_source(Field *out, real t_cur) {$/;"	f	class:Cube
update_source	source/GaussFunction.cpp	/^void GaussFunction::update_source(Field *out, real t_cur) {$/;"	f	class:GaussFunction
update_sources	solver/SolverController.cpp	/^void SolverController::update_sources(real t_cur, bool sync) {$/;"	f	class:SolverController
useBinary	visualisation/visit_writer.cpp	/^static int useBinary = 0;$/;"	v	file:
uu	turbulence/DynamicSmagorinsky.h	/^    Field *uu, *vv, *ww, *uv, *uw, *vw;           \/\/ velocity products$/;"	m	class:DynamicSmagorinsky
uu_f	turbulence/DynamicSmagorinsky.h	/^    Field *uu_f, *vv_f, *ww_f, *uv_f, *uw_f, *vw_f;     \/\/ filters of the velocity products$/;"	m	class:DynamicSmagorinsky
uv	turbulence/DynamicSmagorinsky.h	/^    Field *uu, *vv, *ww, *uv, *uw, *vw;           \/\/ velocity products$/;"	m	class:DynamicSmagorinsky
uv_f	turbulence/DynamicSmagorinsky.h	/^    Field *uu_f, *vv_f, *ww_f, *uv_f, *uw_f, *vw_f;     \/\/ filters of the velocity products$/;"	m	class:DynamicSmagorinsky
uw	turbulence/DynamicSmagorinsky.h	/^    Field *uu, *vv, *ww, *uv, *uw, *vw;           \/\/ velocity products$/;"	m	class:DynamicSmagorinsky
uw_f	turbulence/DynamicSmagorinsky.h	/^    Field *uu_f, *vv_f, *ww_f, *uv_f, *uw_f, *vw_f;     \/\/ filters of the velocity products$/;"	m	class:DynamicSmagorinsky
v	adaption/Vortex.h	/^    Field *u, *v, *w;$/;"	m	class:Vortex
v_a	analysis/Solution.h	/^    Field u_a, v_a, w_a;$/;"	m	class:Solution
v_f	turbulence/DynamicSmagorinsky.h	/^    Field *u_f, *v_f, *w_f;                 \/\/ filtered velocities$/;"	m	class:DynamicSmagorinsky
v_linm	solver/AdvectionSolver.h	/^    Field *v_linm;$/;"	m	class:AdvectionSolver
value	utility/tinyxml2.cpp	/^    char value;$/;"	m	struct:tinyxml2::Entity	file:
vf_vf	turbulence/DynamicSmagorinsky.h	/^    Field *uf_uf, *vf_vf, *wf_wf, *uf_vf, *uf_wf, *vf_wf; \/\/ product of the filtered velocities$/;"	m	class:DynamicSmagorinsky
vf_wf	turbulence/DynamicSmagorinsky.h	/^    Field *uf_uf, *vf_vf, *wf_wf, *uf_vf, *uf_wf, *vf_wf; \/\/ product of the filtered velocities$/;"	m	class:DynamicSmagorinsky
visualise	visualisation/Visual.cpp	/^void Visual::visualise(FieldController *field_controller, const real t) {$/;"	f	class:Visual
vortex	analysis/Solution.cpp	/^void Solution::vortex(const real t) {$/;"	f	class:Solution
vortex_y	analysis/Solution.cpp	/^void Solution::vortex_y(const real t) {$/;"	f	class:Solution
vtkPrepareAndWrite	visualisation/VTKWriter.cpp	/^void VTKWriter::vtkPrepareAndWrite(const char *filename, read_ptr u, read_ptr v, read_ptr w, read_ptr p, read_ptr T) {$/;"	f	class:VTKWriter
vtkPrepareAndWrite	visualisation/VTKWriter.cpp	/^void VTKWriter::vtkPrepareAndWrite(const char *filename, read_ptr u, read_ptr v, read_ptr w, read_ptr p, read_ptr div, read_ptr T, read_ptr C, read_ptr s, read_ptr nu_t, read_ptr S_T) {$/;"	f	class:VTKWriter
vv	turbulence/DynamicSmagorinsky.h	/^    Field *uu, *vv, *ww, *uv, *uw, *vw;           \/\/ velocity products$/;"	m	class:DynamicSmagorinsky
vv_f	turbulence/DynamicSmagorinsky.h	/^    Field *uu_f, *vv_f, *ww_f, *uv_f, *uw_f, *vw_f;     \/\/ filters of the velocity products$/;"	m	class:DynamicSmagorinsky
vw	turbulence/DynamicSmagorinsky.h	/^    Field *uu, *vv, *ww, *uv, *uw, *vw;           \/\/ velocity products$/;"	m	class:DynamicSmagorinsky
vw_f	turbulence/DynamicSmagorinsky.h	/^    Field *uu_f, *vv_f, *ww_f, *uv_f, *uw_f, *vw_f;     \/\/ filters of the velocity products$/;"	m	class:DynamicSmagorinsky
w	adaption/Vortex.h	/^    Field *u, *v, *w;$/;"	m	class:Vortex
w_a	analysis/Solution.h	/^    Field u_a, v_a, w_a;$/;"	m	class:Solution
w_f	turbulence/DynamicSmagorinsky.h	/^    Field *u_f, *v_f, *w_f;                 \/\/ filtered velocities$/;"	m	class:DynamicSmagorinsky
w_linm	solver/AdvectionSolver.h	/^    Field *w_linm;$/;"	m	class:AdvectionSolver
wf_wf	turbulence/DynamicSmagorinsky.h	/^    Field *uf_uf, *vf_vf, *wf_wf, *uf_vf, *uf_wf, *vf_wf; \/\/ product of the filtered velocities$/;"	m	class:DynamicSmagorinsky
write_analytical	visualisation/CSVWriter.cpp	/^void CSVWriter::write_analytical(Solution *solution, const std::string& filename) {$/;"	f	class:CSVWriter
write_analytical	visualisation/VTKWriter.cpp	/^void VTKWriter::write_analytical(Solution *solution, const std::string& filename) {$/;"	f	class:VTKWriter
write_csv	visualisation/Visual.cpp	/^void Visual::write_csv(FieldController *solver, std::string filename){$/;"	f	class:Visual
write_curvilinear_mesh	visualisation/visit_writer.cpp	/^void write_curvilinear_mesh(const char *filename, int ub, int *dims,float *pts,$/;"	f
write_data	visualisation/CSVWriter.cpp	/^void CSVWriter::write_data(std::string *data_titles, real **data, size_t size_data, const std::string& filename) {$/;"	f	class:CSVWriter
write_data	visualisation/Visual.cpp	/^void Visual::write_data(std::string *data_titles, real **data, size_t size_data, std::string filename){$/;"	f	class:Visual
write_file	analysis/Analysis.cpp	/^void Analysis::write_file(const real *field, const std::string& filename, size_t *inner_list, size_t size_inner_list, size_t *boundary_list, size_t size_boundary_list, size_t *obstacle_list, size_t size_obstacle_list) {$/;"	f	class:Analysis
write_float	visualisation/visit_writer.cpp	/^static void write_float(float val)$/;"	f	file:
write_header	visualisation/visit_writer.cpp	/^static void write_header(void)$/;"	f	file:
write_int	visualisation/visit_writer.cpp	/^static void write_int(int val)$/;"	f	file:
write_numerical	visualisation/CSVWriter.cpp	/^void CSVWriter::write_numerical(FieldController *field_controller, const std::string& filename) {$/;"	f	class:CSVWriter
write_numerical	visualisation/VTKWriter.cpp	/^void VTKWriter::write_numerical(FieldController *field_controller, const std::string& filename) {$/;"	f	class:VTKWriter
write_point_mesh	visualisation/visit_writer.cpp	/^void write_point_mesh(const char *filename, int ub, int npts, float *pts,$/;"	f
write_rectilinear_mesh	visualisation/visit_writer.cpp	/^void write_rectilinear_mesh(const char *filename, int ub, int *dims,$/;"	f
write_regular_mesh	visualisation/visit_writer.cpp	/^void write_regular_mesh(const char *filename, int ub, int *dims,$/;"	f
write_string	visualisation/visit_writer.cpp	/^static void write_string(const char *str)$/;"	f	file:
write_unstructured_mesh	visualisation/visit_writer.cpp	/^void write_unstructured_mesh(const char *filename, int ub, int npts,$/;"	f
write_variables	visualisation/visit_writer.cpp	/^void write_variables(int nvars, int *vardim, int *centering,$/;"	f
ww	turbulence/DynamicSmagorinsky.h	/^    Field *uu, *vv, *ww, *uv, *uw, *vw;           \/\/ velocity products$/;"	m	class:DynamicSmagorinsky
ww_f	turbulence/DynamicSmagorinsky.h	/^    Field *uu_f, *vv_f, *ww_f, *uv_f, *uw_f, *vw_f;     \/\/ filters of the velocity products$/;"	m	class:DynamicSmagorinsky
xi	utility/GlobalMacrosTypes.h	76;"	d
yj	utility/GlobalMacrosTypes.h	77;"	d
zero	analysis/Solution.cpp	/^void Solution::zero(const real t) {$/;"	f	class:Solution
zk	utility/GlobalMacrosTypes.h	78;"	d
~AdvectionDiffusionSolver	solver/AdvectionDiffusionSolver.cpp	/^AdvectionDiffusionSolver::~AdvectionDiffusionSolver() {$/;"	f	class:AdvectionDiffusionSolver
~AdvectionSolver	solver/AdvectionSolver.cpp	/^AdvectionSolver::~AdvectionSolver() {$/;"	f	class:AdvectionSolver
~Boundary	boundary/Boundary.cpp	/^Boundary::~Boundary() {$/;"	f	class:Boundary
~BoundaryController	boundary/BoundaryController.cpp	/^BoundaryController::~BoundaryController() {$/;"	f	class:BoundaryController
~BoundaryData	boundary/BoundaryData.cpp	/^BoundaryData::~BoundaryData() {$/;"	f	class:BoundaryData
~BoundaryDataController	boundary/BoundaryDataController.cpp	/^BoundaryDataController::~BoundaryDataController() {$/;"	f	class:BoundaryDataController
~BuoyancyMMS	source/BuoyancyMMS.cpp	/^BuoyancyMMS::~BuoyancyMMS() {$/;"	f	class:BuoyancyMMS
~Cube	source/Cube.cpp	/^Cube::~Cube() {$/;"	f	class:Cube
~DiffusionSolver	solver/DiffusionSolver.cpp	/^DiffusionSolver::~DiffusionSolver() {$/;"	f	class:DiffusionSolver
~DiffusionTurbSolver	solver/DiffusionTurbSolver.cpp	/^DiffusionTurbSolver::~DiffusionTurbSolver() {$/;"	f	class:DiffusionTurbSolver
~DynArray	utility/tinyxml2.h	/^    ~DynArray() {$/;"	f	class:tinyxml2::DynArray
~DynamicSmagorinsky	turbulence/DynamicSmagorinsky.cpp	/^DynamicSmagorinsky::~DynamicSmagorinsky() {$/;"	f	class:DynamicSmagorinsky
~Field	field/Field.cpp	/^Field::~Field() {$/;"	f	class:Field
~FieldController	field/FieldController.cpp	/^FieldController::~FieldController() {$/;"	f	class:FieldController
~GaussFunction	source/GaussFunction.cpp	/^GaussFunction::~GaussFunction() {$/;"	f	class:GaussFunction
~MemPool	utility/tinyxml2.h	/^    virtual ~MemPool() {}$/;"	f	class:tinyxml2::MemPool
~MemPoolT	utility/tinyxml2.h	/^    ~MemPoolT() {$/;"	f	class:tinyxml2::MemPoolT
~Multigrid	boundary/Multigrid.cpp	/^Multigrid::~Multigrid() {$/;"	f	class:Multigrid
~NSSolver	solver/NSSolver.cpp	/^NSSolver::~NSSolver() {$/;"	f	class:NSSolver
~NSTempConSolver	solver/NSTempConSolver.cpp	/^NSTempConSolver::~NSTempConSolver() {$/;"	f	class:NSTempConSolver
~NSTempSolver	solver/NSTempSolver.cpp	/^NSTempSolver::~NSTempSolver() {$/;"	f	class:NSTempSolver
~NSTempTurbConSolver	solver/NSTempTurbConSolver.cpp	/^NSTempTurbConSolver::~NSTempTurbConSolver() {$/;"	f	class:NSTempTurbConSolver
~NSTempTurbSolver	solver/NSTempTurbSolver.cpp	/^NSTempTurbSolver::~NSTempTurbSolver() {$/;"	f	class:NSTempTurbSolver
~NSTurbSolver	solver/NSTurbSolver.cpp	/^NSTurbSolver::~NSTurbSolver() {$/;"	f	class:NSTurbSolver
~Obstacle	boundary/Obstacle.cpp	/^Obstacle::~Obstacle() {$/;"	f	class:Obstacle
~PressureSolver	solver/PressureSolver.cpp	/^PressureSolver::~PressureSolver() {$/;"	f	class:PressureSolver
~SolverController	solver/SolverController.cpp	/^SolverController::~SolverController() {$/;"	f	class:SolverController
~StrPair	utility/tinyxml2.cpp	/^StrPair::~StrPair()$/;"	f	class:tinyxml2::StrPair
~Surface	boundary/Surface.cpp	/^Surface::~Surface() {$/;"	f	class:Surface
~VCycleMG	pressure/VCycleMG.cpp	/^VCycleMG::~VCycleMG() {$/;"	f	class:VCycleMG
~XMLAttribute	utility/tinyxml2.h	/^    virtual ~XMLAttribute()	{}$/;"	f	class:tinyxml2::XMLAttribute
~XMLComment	utility/tinyxml2.cpp	/^XMLComment::~XMLComment()$/;"	f	class:tinyxml2::XMLComment
~XMLDeclaration	utility/tinyxml2.cpp	/^XMLDeclaration::~XMLDeclaration()$/;"	f	class:tinyxml2::XMLDeclaration
~XMLDocument	utility/tinyxml2.cpp	/^XMLDocument::~XMLDocument()$/;"	f	class:tinyxml2::XMLDocument
~XMLElement	utility/tinyxml2.cpp	/^XMLElement::~XMLElement()$/;"	f	class:tinyxml2::XMLElement
~XMLNode	utility/tinyxml2.cpp	/^XMLNode::~XMLNode()$/;"	f	class:tinyxml2::XMLNode
~XMLPrinter	utility/tinyxml2.h	/^    virtual ~XMLPrinter()	{}$/;"	f	class:tinyxml2::XMLPrinter
~XMLText	utility/tinyxml2.h	/^    virtual ~XMLText()												{}$/;"	f	class:tinyxml2::XMLText
~XMLUnknown	utility/tinyxml2.cpp	/^XMLUnknown::~XMLUnknown()$/;"	f	class:tinyxml2::XMLUnknown
~XMLVisitor	utility/tinyxml2.h	/^    virtual ~XMLVisitor() {}$/;"	f	class:tinyxml2::XMLVisitor
